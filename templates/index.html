<!-- templates/index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Staffordshire Flood Dashboard</title>

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>

    <style>
        body { margin: 0; font-family: Arial, Helvetica, sans-serif; background: #f2f2f2; }

        #header {
            background: #1f3a5f;
            color: white;
            padding: 12px 18px;
            font-size: 20px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }

        #header .controls { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }

        #header button, #header select {
            background: rgba(255,255,255,0.12);
            color: white;
            border: 1px solid rgba(255,255,255,0.25);
            border-radius: 6px;
            padding: 6px 10px;
            cursor: pointer;
            font-size: 13px;
        }

        #header button:hover { background: rgba(255,255,255,0.18); }

        #map { height: calc(100vh - 58px); width: 100%; }

        .legend {
            background: white;
            padding: 10px 12px;
            line-height: 1.5;
            box-shadow: 0 0 8px rgba(0,0,0,0.2);
            border-radius: 6px;
            font-size: 13px;
            min-width: 240px;
        }

        .legend h4 { margin: 0 0 8px 0; font-size: 14px; }

        .legend .row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            margin: 4px 0;
        }

        .legend .left { display: flex; align-items: center; gap: 8px; }

        .swatch {
            width: 12px; height: 12px; border-radius: 50%;
            display: inline-block; border: 1px solid rgba(0,0,0,0.25);
        }

        .muted { opacity: 0.65; }
        .small { font-size: 12px; color: #333; }
        .tiny { font-size: 11px; color: #555; }

        .panel {
            background: white;
            padding: 10px 12px;
            line-height: 1.4;
            box-shadow: 0 0 8px rgba(0,0,0,0.2);
            border-radius: 6px;
            font-size: 13px;
            min-width: 340px;
            max-width: 380px;
        }

        .panel h4 { margin: 0 0 8px 0; font-size: 14px; }
        .panel .item { margin: 6px 0; }

        .panel .pill {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 999px;
            font-size: 12px;
            border: 1px solid rgba(0,0,0,0.15);
            background: #f7f7f7;
            max-width: 100%;
            overflow-wrap: anywhere;
        }

        .panel .pill.pillGreen { background: rgba(26,150,65,0.12); border-color: rgba(26,150,65,0.35); }
        .panel .pill.pillAmber { background: rgba(253,174,97,0.18); border-color: rgba(253,174,97,0.55); }
        .panel .pill.pillRed { background: rgba(215,25,28,0.12); border-color: rgba(215,25,28,0.35); }
        .panel .pill.pillHotGreen { background: rgba(26,150,65,0.18); border-color: rgba(26,150,65,0.55); }
        .panel .pill.pillHotAmber { background: rgba(253,174,97,0.22); border-color: rgba(253,174,97,0.65); }
        .panel .pill.pillHotRed { background: rgba(215,25,28,0.18); border-color: rgba(215,25,28,0.55); }

        .panel .section { margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(0,0,0,0.1); }

        .panel .hotspotRow, .panel .attentionRow {
            display: flex; align-items: center; justify-content: space-between;
            gap: 8px; margin: 6px 0;
        }

        .panel .hotspotLink {
            cursor: pointer; text-decoration: underline; color: #1f3a5f; font-size: 12px;
            user-select: none;
        }

        /* Table modal */
        .modalBack {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.45);
            display: none;
            align-items: center;
            justify-content: center;
            padding: 18px;
            z-index: 9999;
        }

        .modal {
            width: min(1100px, 100%);
            max-height: min(80vh, 900px);
            background: white;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0,0,0,0.35);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .modalHeader {
            background: #1f3a5f;
            color: white;
            padding: 10px 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }

        .modalHeader .title { font-weight: bold; }

        .modalHeader .actions { display: flex; gap: 8px; align-items: center; }

        .modalHeader button {
            background: rgba(255,255,255,0.12);
            color: white;
            border: 1px solid rgba(255,255,255,0.25);
            border-radius: 6px;
            padding: 6px 10px;
            cursor: pointer;
            font-size: 13px;
        }

        .modalBody { padding: 10px 12px; overflow: auto; }

        .tableWrap { overflow: auto; border: 1px solid rgba(0,0,0,0.12); border-radius: 8px; }

        table { width: 100%; border-collapse: collapse; font-size: 13px; }

        th, td {
            text-align: left;
            padding: 8px 10px;
            border-bottom: 1px solid rgba(0,0,0,0.08);
            white-space: nowrap;
        }

        th { position: sticky; top: 0; background: #fafafa; z-index: 2; }
        tr:hover td { background: #fcfcfc; }

        .tag {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 999px;
            font-size: 12px;
            border: 1px solid rgba(0,0,0,0.15);
        }

        .tagHigh { background: rgba(215,25,28,0.12); border-color: rgba(215,25,28,0.35); }
        .tagElevated { background: rgba(253,174,97,0.18); border-color: rgba(253,174,97,0.55); }
        .tagNormal { background: rgba(26,150,65,0.12); border-color: rgba(26,150,65,0.35); }
        .tagNoData { background: rgba(153,153,153,0.15); border-color: rgba(153,153,153,0.45); }

        .tagLive { background: rgba(26,150,65,0.10); border-color: rgba(26,150,65,0.25); }
        .tagDelayed { background: rgba(44,123,182,0.10); border-color: rgba(44,123,182,0.25); }
        .tagStale { background: rgba(123,50,148,0.10); border-color: rgba(123,50,148,0.25); }
        .tagOffline { background: rgba(119,119,119,0.10); border-color: rgba(119,119,119,0.25); }

        .searchRow { display: flex; gap: 10px; align-items: center; margin: 0 0 10px 0; }

        .searchRow input {
            flex: 1;
            padding: 8px 10px;
            border-radius: 8px;
            border: 1px solid rgba(0,0,0,0.18);
            font-size: 13px;
        }

        .searchRow .hint { font-size: 12px; color: #555; }

        /* Pulse marker */
        .pulse {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            position: relative;
            pointer-events: none;
        }
        .pulse::after {
            content: "";
            position: absolute;
            left: 50%;
            top: 50%;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: pulse 1.8s infinite;
            opacity: 0.6;
            background: var(--pulse-colour);
        }

        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 0.7; }
            100% { transform: translate(-50%, -50%) scale(3.2); opacity: 0; }
        }
    /* Flood warning greyscale mode */
    .map-greyscale .leaflet-tile-pane {
        filter: grayscale(100%) contrast(1.05) brightness(1.03);
        transition: filter 0.25s ease;
    }
    </style>
</head>

<body>
<div id="header">
    <div>Staffordshire Flood Dashboard</div>
    <div class="controls">
        <select id="markerMode" title="Marker mode">
            <option value="all">Markers: All</option>
            <option value="level">Markers: Level only</option>
            <option value="rainfall">Markers: Rainfall only</option>
        </select>

        <button id="btnTable">Table view</button>
        <button id="btnPdf">SITREP</button>
        <button id="btnWorst">Zoom to worst</button>

        <button id="btnRadar">Radar</button>
        <button id="btnWarnings">Flood warnings</button>
        <button id="btnCatchments">Catchments</button>
        <button id="btnRivers">River labels</button>
    </div>
</div>

<div id="map"></div>

<!-- Table modal -->
<div id="tableModalBack" class="modalBack">
    <div class="modal">
        <div class="modalHeader">
            <div class="title">Table view (level stations only)</div>
            <div class="actions">
                <button id="btnCsv">Export CSV</button>
                <button id="btnCloseTable">Close</button>
            </div>
        </div>
        <div class="modalBody">
            <div class="searchRow">
                <input id="tableSearch" type="text" placeholder="Search station name...">
                <div class="hint">Filters the rows below</div>
            </div>
            <div class="tableWrap">
                <table id="stationsTable">
                    <thead>
                        <tr>
                            <th>Station</th>
                            <th>Level</th>
                            <th>Trend</th>
                            <th>State</th>
                            <th>Reporting</th>
                            <th>Reading time</th>
                            <th>Age</th>
                        </tr>
                    </thead>
                    <tbody id="stationsTableBody">
                        <tr><td colspan="7">Loading...</td></tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
/* ------------------------------------------------------------
   Settings
   ------------------------------------------------------------ */
const REFRESH_MS = 2 * 60 * 1000
const PAGE_LIMIT = 25

const THRESHOLDS = {
    liveHours: 12,
    delayedHours: 48,
    staleHours: 168
}

const COLOURS = {
    high: "#d7191c",
    elevated: "#fdae61",
    normal: "#1a9641",
    delayed: "#2c7bb6",
    stale: "#7b3294",
    offline: "#777777",
    nodata: "#999999"
}

const HOTSPOT_RADIUS_KM = 5
const HOTSPOT_MIN_POINTS = 2
const BASELINE_KEY = "sfdb_sitrep_baseline_v1"

/* ------------------------------------------------------------
   Map init + panes
   ------------------------------------------------------------ */
const map = L.map("map").setView([52.9, -2.05], 9)
// ---- Z ordering panes ----
map.createPane("polygonsPane")
map.getPane("polygonsPane").style.zIndex = 350
map.getPane("polygonsPane").style.pointerEvents = "auto"

map.createPane("stationsPane")
map.getPane("stationsPane").style.zIndex = 650
L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    attribution: "&copy; OpenStreetMap contributors"
}).addTo(map)

/*
CircleMarkers live in the SVG overlay by default, same as polygons
That means catchments can sit on top and steal clicks
Fix: give stations their own higher pane, and catchments a lower pane
*/
map.createPane("polygonsPane")
map.getPane("polygonsPane").style.zIndex = 420

map.createPane("labelsPane")
map.getPane("labelsPane").style.zIndex = 630

map.createPane("stationsPane")
map.getPane("stationsPane").style.zIndex = 650

map.createPane("pulsePane")
map.getPane("pulsePane").style.zIndex = 640
map.getPane("pulsePane").style.pointerEvents = "none"

/* ------------------------------------------------------------
   State
   ------------------------------------------------------------ */
let boundaryLayer = null
let markers = {}
let stationsLoaded = false
let lastRefreshLocal = null

let latestItemsById = {}
let latestLevelRows = []
let previousSnapshotById = null
let latestHotspots = []
let worstStation = null

let radarLayer = null
let radarOn = false

let warningsLayer = null
let warningsOn = false

let catchmentsLayer = null
let catchmentsOn = false

let riverLabelsLayer = null
let riverLabelsOn = false

let markerMode = "all"

let pulseMarkers = {}
function applyMarkerMode() {
    const want = markerMode || "all"
    // Hide pulse markers when not showing level markers
    const hidePulses = (want === "rainfall")
    Object.keys(pulseMarkers).forEach(id => {
    const pm = pulseMarkers[id]
    if (!pm) return
    if (hidePulses) {
        if (map.hasLayer(pm)) map.removeLayer(pm)
    } else {
        if (!map.hasLayer(pm)) pm.addTo(map)
    }
    })

    Object.keys(markers).forEach(id => {
        const m = markers[id]
        const item = latestItemsById[id]

        // If we do not have status for this marker yet, leave it visible
        if (!item) {
            if (!map.hasLayer(m)) m.addTo(map)
            return
        }

        const p = (item.parameter || "").toLowerCase()
        const u = (item.unitShort || "").toLowerCase()

        const isLevel = p === "level" || u === "m"
        const isRain = p === "rainfall" || u === "mm"

        let show = true
        if (want === "level") show = isLevel
        if (want === "rainfall") show = isRain

        if (show) {
            if (!map.hasLayer(m)) m.addTo(map)
        } else {
            if (map.hasLayer(m)) map.removeLayer(m)
        }
    })
}
function nowMs() { return Date.now() }

function parseIsoMs(iso) {
    if (!iso) return null
    const d = new Date(iso)
    const t = d.getTime()
    if (Number.isNaN(t)) return null
    return t
}

function formatDateTime(iso) {
    if (!iso) return "Unknown"
    return iso.replace("T", " ").replace("Z", "")
}

function formatAge(ms) {
    if (ms == null) return "Unknown"
    const totalSeconds = Math.max(0, Math.floor(ms / 1000))
    const mins = Math.floor(totalSeconds / 60)
    const hours = Math.floor(mins / 60)
    const days = Math.floor(hours / 24)

    const remHours = hours % 24
    const remMins = mins % 60

    if (days > 0) return `${days}d ${remHours}h`
    if (hours > 0) return `${hours}h ${remMins}m`
    return `${mins}m`
}

function classifyFreshness(dateTimeIso) {
    const t = parseIsoMs(dateTimeIso)
    if (t == null) return { status: "Offline", ageMs: null }

    const ageMs = nowMs() - t
    const ageHours = ageMs / (1000 * 60 * 60)

    if (ageHours <= THRESHOLDS.liveHours) return { status: "Live", ageMs }
    if (ageHours <= THRESHOLDS.delayedHours) return { status: "Delayed", ageMs }
    if (ageHours <= THRESHOLDS.staleHours) return { status: "Stale", ageMs }
    return { status: "Offline", ageMs }
}

function stateToColour(state) {
    if (state === "High") return COLOURS.high
    if (state === "Elevated") return COLOURS.elevated
    if (state === "Normal") return COLOURS.normal
    if (state === "NoData") return COLOURS.nodata
    return COLOURS.nodata
}

function markerBaseStyle() {
    return { radius: 6, color: "#666", fillColor: "#999", fillOpacity: 0.7, weight: 2, opacity: 1, pane: "stationsPane" }
}

function setMarkerStyle(marker, colour, opts) {
    const extra = opts || {}
    marker.setStyle({
        color: colour,
        fillColor: colour,
        fillOpacity: extra.fillOpacity != null ? extra.fillOpacity : 0.75,
        opacity: extra.opacity != null ? extra.opacity : 1,
        weight: extra.weight != null ? extra.weight : 2
    })
}

function formatValueAndUnit(item) {
    const v = item.value
    const u = item.unitShort || item.unit || ""
    if (v == null) return { label: "Value", text: "Unknown" }

    const unitText = u ? ` ${u}` : ""
    const p = (item.parameter || "").toLowerCase()
    const isLevel = p === "level" || (u || "").toLowerCase() === "m"

    if (isLevel) return { label: "Level", text: `${v}${unitText}` }
    return { label: "Value", text: `${v}${unitText}` }
}

function escapeHtml(s) {
    return String(s)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;")
}

function buildPopup(item, freshness) {
    const ageText = freshness.ageMs == null ? "Unknown" : formatAge(freshness.ageMs)
    const v = formatValueAndUnit(item)

    const district = item.district ? `District: ${escapeHtml(item.district)}<br>` : ""
    const river = item.riverName ? `River: ${escapeHtml(item.riverName)}<br>` : ""
    const catchment = item.catchmentName ? `Catchment: ${escapeHtml(item.catchmentName)}<br>` : ""

    return `
        <b>${escapeHtml(item.label || item.id)}</b><br>
        ${district}
        ${river}
        ${catchment}
        ${v.label}: ${escapeHtml(v.text)}<br>
        Trend: ${escapeHtml(item.trend || "Unknown")}<br>
        State: ${escapeHtml(item.state || "Unknown")}<br>
        Reporting: ${escapeHtml(freshness.status)}<br>
        Reading time: ${escapeHtml(formatDateTime(item.dateTime) || "Unknown")}<br>
        Age: ${escapeHtml(ageText)}
    `
}

/* ------------------------------------------------------------
   Legend + intel panels
   ------------------------------------------------------------ */
function createLegendControl() {
    const legend = L.control({ position: "bottomleft" })

    legend.onAdd = function() {
        const div = L.DomUtil.create("div", "legend")
        div.innerHTML = `
    <div id="eaWarningsBox" style="margin-bottom:10px;">
        <h4>Flood warnings (EA)</h4>

        <div class="row">
            <div class="left"><span class="swatch" style="background:${COLOURS.high}"></span>Severe</div>
            <div><b id="eaSevere">0</b></div>
        </div>

        <div class="row">
            <div class="left"><span class="swatch" style="background:${COLOURS.elevated}"></span>Warnings</div>
            <div><b id="eaWarnings">0</b></div>
        </div>

        <div class="row">
            <div class="left"><span class="swatch" style="background:#ffeb3b"></span>Alerts</div>
            <div><b id="eaAlerts">0</b></div>
        </div>

        <div class="tiny" style="margin-top:6px;">
            Last EA update: <b id="eaLast">Unknown</b>
        </div>

        <hr>
    </div>

    <h4>Status</h4>

    <div class="row"><div class="left"><span class="swatch" style="background:${COLOURS.high}"></span>High</div><div><b id="countHigh">0</b></div></div>
    <div class="row"><div class="left"><span class="swatch" style="background:${COLOURS.elevated}"></span>Elevated</div><div><b id="countElevated">0</b></div></div>
    <div class="row"><div class="left"><span class="swatch" style="background:${COLOURS.normal}"></span>Normal</div><div><b id="countNormal">0</b></div></div>
    <div class="row"><div class="left"><span class="swatch" style="background:${COLOURS.delayed}"></span>Delayed</div><div><b id="countDelayed">0</b></div></div>
    <div class="row"><div class="left"><span class="swatch" style="background:${COLOURS.stale}"></span>Stale</div><div><b id="countStale">0</b></div></div>
    <div class="row"><div class="left"><span class="swatch" style="background:${COLOURS.offline}"></span>Offline</div><div><b id="countOffline">0</b></div></div>
    <div class="row"><div class="left"><span class="swatch muted" style="background:${COLOURS.nodata}"></span>No data</div><div><b id="countNoData">0</b></div></div>

    <hr>

    <div class="small">Last refreshed: <b id="lastRef">Never</b></div>
    <div class="tiny">
        Reading freshness: Live ≤ ${THRESHOLDS.liveHours}h, Delayed ≤ ${THRESHOLDS.delayedHours}h, Stale ≤ ${THRESHOLDS.staleHours}h, Offline &gt; ${THRESHOLDS.staleHours}h
    </div>
`
        return div
    }

    legend.addTo(map)
}

function createIntelPanel() {
    const panel = L.control({ position: "topright" })

    panel.onAdd = function() {
        const div = L.DomUtil.create("div", "panel")
        div.innerHTML = `
            <h4>Intelligence</h4>

            <div class="item">Highest risk: <span class="pill" id="intelWorst">Unknown</span></div>
            <div class="item">Rising level sites: <span class="pill" id="intelRising">0</span></div>
            <div class="item">Offline sites: <span class="pill" id="intelOffline">0</span></div>
            <div class="item">Last update: <span class="pill" id="intelLast">Never</span></div>

            <div class="section">
                <div class="item"><b>Hotspots (within ${HOTSPOT_RADIUS_KM} km)</b></div>
                <div id="hotspotList" class="tiny">None</div>
            </div>

            <div class="section">
                <div class="item"><b>Areas of interest</b></div>
                <div id="attentionList" class="tiny">None</div>
            </div>

            <div class="section">
                <div class="item"><b>Changes since last refresh</b></div>
                <div class="tiny" id="deltaSummary">No previous snapshot yet</div>
            </div>

            <div class="tiny">Highest risk uses State then freshness then trend, plus missing data penalty.</div>
        `
        return div
    }

    panel.addTo(map)
}

createLegendControl()
createIntelPanel()

function updateLegendCounts(counts) {
    const set = (id, val) => {
        const el = document.getElementById(id)
        if (el) el.textContent = String(val)
    }

    set("countHigh", counts.high)
    set("countElevated", counts.elevated)
    set("countNormal", counts.normal)
    set("countDelayed", counts.delayed)
    set("countStale", counts.stale)
    set("countOffline", counts.offline)
    set("countNoData", counts.nodata)

    const last = document.getElementById("lastRef")
    if (last) last.textContent = lastRefreshLocal ? lastRefreshLocal : "Never"
}

function setIntel(id, text) {
    const el = document.getElementById(id)
    if (el) el.textContent = String(text)
}

function worstScore(item, freshness) {
    let score = 0

    if (item.state === "High") score += 300
    else if (item.state === "Elevated") score += 200
    else if (item.state === "Normal") score += 100

    if (freshness.status === "Delayed") score += 30
    else if (freshness.status === "Stale") score += 60
    else if (freshness.status === "Offline") score += 90

    if (item.trend === "Rising") score += 15
    else if (item.trend === "Falling") score += 5

    if (item.value == null || item.dateTime == null) score += 120

    return score
}

/* ------------------------------------------------------------
   Table
   ------------------------------------------------------------ */
function downloadText(filename, text, mime) {
    const blob = new Blob([text], { type: mime || "text/plain" })
    const url = URL.createObjectURL(blob)
    const a = document.createElement("a")
    a.href = url
    a.download = filename
    document.body.appendChild(a)
    a.click()
    a.remove()
    URL.revokeObjectURL(url)
}

function csvEscape(v) {
    const s = String(v ?? "")
    if (s.includes(",") || s.includes('"') || s.includes("\n")) {
        return `"${s.replaceAll('"', '""')}"`
    }
    return s
}

function tagClassForState(state) {
    if (state === "High") return "tag tagHigh"
    if (state === "Elevated") return "tag tagElevated"
    if (state === "Normal") return "tag tagNormal"
    return "tag tagNoData"
}

function tagClassForFreshness(status) {
    if (status === "Live") return "tag tagLive"
    if (status === "Delayed") return "tag tagDelayed"
    if (status === "Stale") return "tag tagStale"
    return "tag tagOffline"
}

function renderTable() {
    const body = document.getElementById("stationsTableBody")
    const q = (document.getElementById("tableSearch")?.value || "").trim().toLowerCase()
    if (!body) return

    const rows = latestLevelRows.filter(r => {
        if (!q) return true
        const name = (r.item.label || r.item.id || "").toLowerCase()
        return name.includes(q)
    })

    if (!rows.length) {
        body.innerHTML = `<tr><td colspan="7">No matching stations</td></tr>`
        return
    }

    body.innerHTML = rows.map(r => {
        const item = r.item
        const freshness = r.freshness

        const v = formatValueAndUnit(item)
        const ageText = freshness.ageMs == null ? "Unknown" : formatAge(freshness.ageMs)

        const stateTag = `<span class="${tagClassForState(item.state)}">${escapeHtml(item.state || "NoData")}</span>`
        const repTag = `<span class="${tagClassForFreshness(freshness.status)}">${escapeHtml(freshness.status)}</span>`

        return `
            <tr>
                <td>${escapeHtml(item.label || item.id || "")}</td>
                <td>${escapeHtml(v.text)}</td>
                <td>${escapeHtml(item.trend || "Unknown")}</td>
                <td>${stateTag}</td>
                <td>${repTag}</td>
                <td>${escapeHtml(formatDateTime(item.dateTime))}</td>
                <td>${escapeHtml(ageText)}</td>
            </tr>
        `
    }).join("")
}

function exportCsvFromTable() {
    const rows = latestLevelRows.map(r => {
        const item = r.item
        const freshness = r.freshness
        const v = formatValueAndUnit(item)
        const ageText = freshness.ageMs == null ? "Unknown" : formatAge(freshness.ageMs)
        return [
            item.label || item.id || "",
            v.text,
            item.trend || "",
            item.state || "",
            freshness.status || "",
            formatDateTime(item.dateTime) || "",
            ageText
        ]
    })

    const header = ["Station", "Level", "Trend", "State", "Reporting", "Reading time", "Age"]
    const lines = [header, ...rows].map(r => r.map(csvEscape).join(",")).join("\n")
    const stamp = new Date().toISOString().replaceAll(":", "").replaceAll("-", "").slice(0, 15)
    downloadText(`staffordshire_levels_${stamp}.csv`, lines, "text/csv")
}

/* ------------------------------------------------------------
   Hotspot detection
   ------------------------------------------------------------ */
function toRad(d) { return d * Math.PI / 180 }

function haversineKm(aLat, aLon, bLat, bLon) {
    const R = 6371
    const dLat = toRad(bLat - aLat)
    const dLon = toRad(bLon - aLon)
    const s1 = Math.sin(dLat / 2)
    const s2 = Math.sin(dLon / 2)
    const q = s1 * s1 + Math.cos(toRad(aLat)) * Math.cos(toRad(bLat)) * s2 * s2
    return 2 * R * Math.asin(Math.min(1, Math.sqrt(q)))
}

function hotspotWeight(item, freshness) {
    let w = 0
    if (item.state === "High") w += 10
    if (item.state === "Elevated") w += 6
    if (item.trend === "Rising") w += 5
    if (freshness.status === "Offline") w -= 3
    if (item.value == null || item.dateTime == null) w += 2
    return w
}

function buildHotspots(levelRows) {
    const candidates = levelRows
        .map(r => ({ ...r, lat: r.item.lat, lon: r.item.long }))
        .filter(r => {
            if (r.lat == null || r.lon == null) return false
            const st = r.item.state
            const rising = r.item.trend === "Rising"
            return st === "High" || st === "Elevated" || rising
        })

    if (candidates.length < HOTSPOT_MIN_POINTS) return []

    const visited = new Set()
    const clusters = []

    for (let i = 0; i < candidates.length; i++) {
        if (visited.has(i)) continue

        const queue = [i]
        const members = []
        visited.add(i)

        while (queue.length) {
            const idx = queue.pop()
            const a = candidates[idx]
            members.push(a)

            for (let j = 0; j < candidates.length; j++) {
                if (visited.has(j)) continue
                const b = candidates[j]
                const dist = haversineKm(a.lat, a.lon, b.lat, b.lon)
                if (dist <= HOTSPOT_RADIUS_KM) {
                    visited.add(j)
                    queue.push(j)
                }
            }
        }

        if (members.length >= HOTSPOT_MIN_POINTS) {
            let sumLat = 0, sumLon = 0, sumW = 0
            members.forEach(m => {
                const w = hotspotWeight(m.item, m.freshness)
                sumLat += m.lat
                sumLon += m.lon
                sumW += w
            })

            const centroid = { lat: sumLat / members.length, lon: sumLon / members.length }

            const worstMember = members
                .slice()
                .sort((a, b) => (hotspotWeight(b.item, b.freshness) - hotspotWeight(a.item, a.freshness)))[0]

            clusters.push({
                count: members.length,
                weight: sumW,
                centroid,
                worst: worstMember ? (worstMember.item.label || worstMember.item.id) : "Unknown"
            })
        }
    }

    clusters.sort((a, b) => {
        if (b.weight !== a.weight) return b.weight - a.weight
        return b.count - a.count
    })

    return clusters.slice(0, 5)
}

/* This was missing in your file and breaks the whole script */
function hotspotClass(count) {
    if (count >= 4) return "pillHotRed"
    if (count >= 2) return "pillHotAmber"
    return "pillHotGreen"
}

function updateHotspotPanel() {
    const el = document.getElementById("hotspotList")
    if (!el) return

    if (!latestHotspots.length) {
        el.innerHTML = "None"
        return
    }

    el.innerHTML = latestHotspots.map((h, idx) => {
        return `
            <div class="hotspotRow">
                <div>
                    <span class="pill">#${idx + 1}</span>
                    <span class="pill ${hotspotClass(h.count)}">${h.count} sites</span>
                    <span class="pill">Worst: ${escapeHtml(h.worst)}</span>
                </div>
                <div class="hotspotLink" data-hotspot="${idx}">Zoom</div>
            </div>
        `
    }).join("")

    el.querySelectorAll(".hotspotLink").forEach(a => {
        a.addEventListener("click", () => {
            const idx = Number(a.getAttribute("data-hotspot"))
            const h = latestHotspots[idx]
            if (!h) return
            map.setView([h.centroid.lat, h.centroid.lon], 12)
        })
    })
}

/* ------------------------------------------------------------
   Change detection since last refresh
   ------------------------------------------------------------ */
function makeSnapshot(levelRows) {
    const snap = {}
    levelRows.forEach(r => {
        const it = r.item
        const fr = r.freshness
        snap[it.id] = {
            id: it.id,
            label: it.label || it.id,
            state: it.state || "NoData",
            trend: it.trend || "NoData",
            reporting: fr.status || "Offline",
            value: it.value,
            dateTime: it.dateTime,
            unit: it.unitShort || it.unit || "",
            lat: it.lat,
            lon: it.long,
            district: it.district || null,
            riverName: it.riverName || null,
            catchmentName: it.catchmentName || null,
            rate: it.trendRatePerHour != null ? Number(it.trendRatePerHour) : null
        }
    })
    return snap
}

function summariseDelta(prevSnap, currSnap) {
    if (!prevSnap) return { text: "No previous snapshot yet", notable: [] }

    let escalatedToHigh = 0
    let escalatedToElevated = 0
    let newlyOffline = 0
    let newlyNoData = 0
    let newlyRising = 0

    const notable = []
    const ids = new Set([...Object.keys(prevSnap), ...Object.keys(currSnap)])

    ids.forEach(id => {
        const p = prevSnap[id]
        const c = currSnap[id]
        if (!c) return

        const pState = p ? p.state : "NoData"
        const cState = c.state

        const pRep = p ? p.reporting : "Offline"
        const cRep = c.reporting

        const pTrend = p ? p.trend : "NoData"
        const cTrend = c.trend

        const pHasData = p && p.value != null && p.dateTime
        const cHasData = c.value != null && c.dateTime

        if (pState !== "High" && cState === "High") {
            escalatedToHigh += 1
            notable.push(`${c.label} escalated to High`)
        }

        if ((pState !== "High" && pState !== "Elevated") && cState === "Elevated") {
            escalatedToElevated += 1
            notable.push(`${c.label} escalated to Elevated`)
        }

        if (pRep !== "Offline" && cRep === "Offline") {
            newlyOffline += 1
            notable.push(`${c.label} is now Offline`)
        }

        if (pHasData && !cHasData) {
            newlyNoData += 1
            notable.push(`${c.label} has lost data`)
        }

        if (pTrend !== "Rising" && cTrend === "Rising") {
            newlyRising += 1
            notable.push(`${c.label} is now Rising`)
        }
    })

    const parts = []
    if (escalatedToHigh) parts.push(`+${escalatedToHigh} to High`)
    if (escalatedToElevated) parts.push(`+${escalatedToElevated} to Elevated`)
    if (newlyRising) parts.push(`+${newlyRising} now Rising`)
    if (newlyOffline) parts.push(`+${newlyOffline} now Offline`)
    if (newlyNoData) parts.push(`+${newlyNoData} lost data`)

    const text = parts.length ? parts.join(" | ") : "No material changes since last refresh"
    return { text, notable: notable.slice(0, 8) }
}

function updateDeltaPanel(delta) {
    const el = document.getElementById("deltaSummary")
    if (!el) return

    if (!delta) {
        el.textContent = "No previous snapshot yet"
        return
    }

    let html = `<div>${escapeHtml(delta.text)}</div>`
    if (delta.notable && delta.notable.length) {
        html += `<div style="margin-top:6px">`
        delta.notable.forEach(n => { html += `<div>• ${escapeHtml(n)}</div>` })
        html += `</div>`
    }
    el.innerHTML = html
}

/* ------------------------------------------------------------
   Officer attention list + pulse
   ------------------------------------------------------------ */
function pillClassForState(state) {
    if (state === "High") return "pillRed"
    if (state === "Elevated") return "pillAmber"
    if (state === "Normal") return "pillGreen"
    return ""
}

function pillClassForTrend(trend) {
    if (trend === "Rising") return "pillRed"
    if (trend === "Falling") return "pillAmber"
    if (trend === "Steady") return "pillGreen"
    return ""
}

function pillClassForFreshness(status) {
    if (status === "Offline") return "pillRed"
    if (status === "Stale") return "pillAmber"
    if (status === "Delayed") return "pillAmber"
    if (status === "Live") return "pillGreen"
    return ""
}

function computeAttention(levelRows) {
    return levelRows
        .filter(r => r.item && r.item.value != null)
        .map(r => {
            const rate = r.item.trendRatePerHour != null ? Number(r.item.trendRatePerHour) : null
            const score =
                (r.item.state === "High" ? 300 : r.item.state === "Elevated" ? 200 : r.item.state === "Normal" ? 100 : 0) +
                (r.freshness.status === "Offline" ? 90 : r.freshness.status === "Stale" ? 60 : r.freshness.status === "Delayed" ? 30 : 0) +
                (r.item.trend === "Rising" ? 15 : r.item.trend === "Falling" ? 5 : 0) +
                (rate != null ? Math.min(50, Math.max(0, rate * 10)) : 0)
            return { r, score, rate }
        })
        .sort((a, b) => b.score - a.score)
        .slice(0, 8)
}

function updateAttentionPanel(attention) {
    const el = document.getElementById("attentionList")
    if (!el) return
    if (!attention.length) {
        el.innerHTML = "None"
        return
    }

el.innerHTML = attention.map(a => {
        const it = a.r.item
        const fr = a.r.freshness
        const rateTxt = a.rate != null ? `${a.rate.toFixed(3)} /hr` : "n/a"

        const stateClass = pillClassForState(it.state)
        const trendClass = pillClassForTrend(it.trend)
        const freshClass = pillClassForFreshness(fr.status)

        return `
            <div class="attentionRow">
                <div>
                    <span class="pill ${stateClass}">${escapeHtml(it.state || "NoData")}</span>
                    <span class="pill ${trendClass}">${escapeHtml(it.trend || "Unknown")}</span>
                    <span class="pill ${freshClass}">${escapeHtml(fr.status || "Unknown")}</span>
                    <span class="pill">${escapeHtml(rateTxt)}</span>
                    <div class="tiny">${escapeHtml(it.label || it.id)}</div>
                </div>
                <div class="hotspotLink" data-station="${escapeHtml(it.id)}">Zoom</div>
            </div>
        `
    }).join("")

    el.querySelectorAll(".hotspotLink").forEach(a => {
        const sid = a.getAttribute("data-station")
        a.addEventListener("click", () => zoomToStation(sid))
    })
}

function districtSeverityScore(state) {
    if (state === "High") return 3
    if (state === "Elevated") return 2
    if (state === "Normal") return 1
    return 0
}

function updateTrafficLights(levelRows) {
    const el = document.getElementById("trafficLights")
    if (!el) return

    const byDistrict = {}
    levelRows.forEach(r => {
        const d = r.item.district || "Unknown"
        const sev = districtSeverityScore(r.item.state)
        byDistrict[d] = Math.max(byDistrict[d] || 0, sev)
    })

    const entries = Object.entries(byDistrict).sort((a, b) => a[0].localeCompare(b[0]))
    if (!entries.length) {
        el.innerHTML = `<div class="tiny">No district data</div>`
        return
    }

    el.innerHTML = entries.map(([name, sev]) => {
        const dotClass = sev === 3 ? "dot dotRed" : sev === 2 ? "dot dotAmber" : sev === 1 ? "dot dotGreen" : "dot dotGrey"
        return `
            <div class="trafficItem">
                <div>${escapeHtml(name)}</div>
                <span class="${dotClass}"></span>
            </div>
        `
    }).join("")
}

/* ------------------------------------------------------------
   Pulse markers
   ------------------------------------------------------------ */

function clearPulseMarkers() {
    Object.keys(pulseMarkers).forEach(id => {
        try { map.removeLayer(pulseMarkers[id]) } catch (e) {}
    })
    pulseMarkers = {}
}

function applyPulseToFastestRising(levelRows) {
    clearPulseMarkers()

    const rising = levelRows
        .filter(r => r.item.trend === "Rising" && r.item.lat != null && r.item.long != null)
        .map(r => {
            const rate = r.item.trendRatePerHour != null ? Number(r.item.trendRatePerHour) : null
            return { r, rate }
        })
        .filter(x => x.rate != null && Number.isFinite(x.rate))
        .sort((a, b) => b.rate - a.rate)
        .slice(0, 5)

    rising.forEach(x => {
        const it = x.r.item
        const colour = stateToColour(it.state)

        const icon = L.divIcon({
            className: "",
            html: `<div class="pulse" style="background:${colour}; --pulse-colour:${colour}"></div>`,
            iconSize: [12, 12],
            iconAnchor: [6, 6]
        })

        const m = L.marker([it.lat, it.long], {
            icon,
            interactive: false,
            keyboard: false,
            pane: "shadowPane"
        }).addTo(map)

        pulseMarkers[it.id] = m
    })
}

function zoomToStation(stationId) {
    if (!stationId) return
    const m = markers[stationId]
    if (!m) return
    try {
        map.setView(m.getLatLng(), 13)
        m.openPopup()
    } catch (e) {}
}

/* ------------------------------------------------------------
   Overlays
   ------------------------------------------------------------ */

let radarFrameUrl = null
let radarLoading = false

function removeAnyRadarLayers() {
    if (radarLayer && map.hasLayer(radarLayer)) {
        radarLayer.removeFrom(map)
    }

    map.eachLayer(l => {
        const url = (l && typeof l.getTileUrl === "function") ? l.getTileUrl({ x: 0, y: 0, z: 0 }) : ""
        if (typeof url === "string" && url.includes("rainviewer.com")) {
            try { map.removeLayer(l) } catch (e) {}
        }
    })
}

async function toggleRadar() {
    if (radarLayer) {
        if (map.hasLayer(radarLayer)) {
            removeAnyRadarLayers()
            radarOn = false
        } else {
            radarLayer.addTo(map)
            radarOn = true
        }
        return
    }

    if (radarLoading) return
    radarLoading = true

    try {
        const res = await fetch("https://api.rainviewer.com/public/weather-maps.json")
        if (!res.ok) return

        const j = await res.json()
        const frames = j?.radar?.past
        if (!frames || !frames.length) return

        const frame = frames[frames.length - 1]
        const host = j.host || "https://tilecache.rainviewer.com"
        const path = frame.path
        if (!path) return

        radarFrameUrl = `${host}${path}/256/{z}/{x}/{y}/2/1_1.png`

        radarLayer = L.tileLayer(radarFrameUrl, {
            opacity: 0.55,
            tileSize: 256,
            maxNativeZoom: 7,
            maxZoom: 18,
            updateWhenIdle: true,
            keepBuffer: 2
        })

        radarLayer.addTo(map)
        radarOn = true
    } catch (e) {
    } finally {
        radarLoading = false
    }
}

async function toggleWarnings() {
    warningsOn = !warningsOn

    // If turning warnings OFF, remove layer and remove greyscale
    if (!warningsOn) {
        if (warningsLayer) {
            map.removeLayer(warningsLayer)
            warningsLayer = null
        }
        document.getElementById("map").classList.remove("map-greyscale")
        return
    }

    try {
        const res = await fetch("/staffordshire/floodwarnings")
        if (!res.ok) return

        const raw = await res.json()

        const geo = {
            type: "FeatureCollection",
            features: (raw.features || []).filter(f => {
                const lvl = f?.properties?.severityLevel
                return lvl === 1 || lvl === 2
            })
        }

        if (warningsLayer) map.removeLayer(warningsLayer)

        warningsLayer = L.geoJSON(geo, {
            pane: "polygonsPane",

            style: (f) => ({
                color: "#c9091c",
                weight: 2,
                fillOpacity: 0.25
            }),

            onEachFeature: (feature, layer) => {
                const p = feature.properties || {}

                layer.bindPopup(`
                    <b>${p.severity || "Flood warning"}</b><br>
                    ${p.area || ""}<br><br>
                    ${p.message || ""}
                `)
            }
        }).addTo(map)

        // Turn greyscale ON when warnings are ON
        document.getElementById("map").classList.add("map-greyscale")

    } catch (e) {}
}

/* Make a non-interactive pane for polygons so they don't block station clicks */
if (!map.getPane("polygonsPane")) {
    map.createPane("polygonsPane")
    map.getPane("polygonsPane").style.zIndex = 250
    map.getPane("polygonsPane").style.pointerEvents = "none"
}

async function toggleCatchments() {
    catchmentsOn = !catchmentsOn
    if (!catchmentsOn) {
        if (catchmentsLayer) { map.removeLayer(catchmentsLayer); catchmentsLayer = null }
        return
    }

    try {
        const res = await fetch("/staffordshire/catchments")
        if (!res.ok) return
        const geo = await res.json()

        if (catchmentsLayer) map.removeLayer(catchmentsLayer)

        catchmentsLayer = L.geoJSON(geo, {
            pane: "polygonsPane",
            style: { color: "#111111", weight: 1, fillOpacity: 0.06 },
            onEachFeature: (f, layer) => {
                const p = f.properties || {}
                layer.bindPopup(`<b>${escapeHtml(p.catchmentName || "Catchment")}</b><br>Stations: ${escapeHtml(p.stationCount || 0)}`)
            }
        }).addTo(map)

        /* Extra safety: ensure SVG paths don't eat clicks */
        try {
            const el = catchmentsLayer.getPane && catchmentsLayer.getPane()
            if (el) el.style.pointerEvents = "none"
        } catch (e) {}
    } catch (e) {}
}

async function toggleDistricts() {
    districtsOn = !districtsOn
    if (!districtsOn) {
        if (districtsLayer) { map.removeLayer(districtsLayer); districtsLayer = null }
        return
    }

    try {
        const res = await fetch("/staffordshire/districts")
        if (!res.ok) return
        const geo = await res.json()

        if (districtsLayer) map.removeLayer(districtsLayer)

        districtsLayer = L.geoJSON(geo, {
            pane: "polygonsPane",
            style: { color: "#333333", weight: 1, fillOpacity: 0 },
            onEachFeature: (f, layer) => {
                const p = f.properties || {}
                layer.bindPopup(`<b>${escapeHtml(p.name || "District")}</b>`)
            }
        }).addTo(map)

        try {
            const el = districtsLayer.getPane && districtsLayer.getPane()
            if (el) el.style.pointerEvents = "none"
        } catch (e) {}
    } catch (e) {}
}

/* River labels: always rebuild from latestLevelRows, and rebuild after refresh if toggled on */
function rebuildRiverLabels() {
    if (riverLabelsLayer) { try { map.removeLayer(riverLabelsLayer) } catch (e) {} }
    riverLabelsLayer = null

    const groups = {}
    latestLevelRows.forEach(r => {
        const rn = r.item.riverName
        if (!rn || r.item.lat == null || r.item.long == null) return
        groups[rn] = groups[rn] || []
        groups[rn].push([r.item.lat, r.item.long])
    })

    const feats = []
    Object.entries(groups).forEach(([name, pts]) => {
        if (!pts.length) return
        const avgLat = pts.reduce((a, p) => a + p[0], 0) / pts.length
        const avgLon = pts.reduce((a, p) => a + p[1], 0) / pts.length
        feats.push({ name, lat: avgLat, lon: avgLon })
    })

    riverLabelsLayer = L.layerGroup()
    feats.forEach(f => {
        const icon = L.divIcon({
            className: "",
            html: `<div style="background:rgba(255,255,255,0.85);border:1px solid rgba(0,0,0,0.2);border-radius:999px;padding:2px 8px;font-size:11px">${escapeHtml(f.name)}</div>`,
            iconSize: null
        })
        L.marker([f.lat, f.lon], { icon, interactive: false, keyboard: false }).addTo(riverLabelsLayer)
    })

    riverLabelsLayer.addTo(map)
}

function toggleRiverLabels() {
    riverLabelsOn = !riverLabelsOn
    if (!riverLabelsOn) {
        if (riverLabelsLayer) { map.removeLayer(riverLabelsLayer); riverLabelsLayer = null }
        return
    }
    rebuildRiverLabels()
}
async function refreshFloodWarningsSummary() {
  // Ensure we always have a safe default object
  window.latestFloodWarnings = window.latestFloodWarnings || { alerts: 0, warnings: 0, severe: 0 }

  try {
    const res = await fetch("/api/flood-warnings-summary", { cache: "no-store", credentials: "same-origin" })
    if (!res.ok) return

    const data = await res.json()
    const c = data?.counts || {}

    const nextAlerts = Number(c.alert || 0)
    const nextWarnings = Number(c.warning || 0)
    const nextSevere = Number(c.severe || 0)

    const previous = window.latestFloodWarnings || null
    const previousSig = previous ? `${previous.severe}|${previous.warnings}|${previous.alerts}` : null
    const nextSig = `${nextSevere}|${nextWarnings}|${nextAlerts}`

    // Update memory
    window.latestFloodWarnings = {
      alerts: nextAlerts,
      warnings: nextWarnings,
      severe: nextSevere,
      fetchedAtEpoch: data?.fetchedAtEpoch || null,
      changed: previousSig !== null && previousSig !== nextSig
    }

    // Update legend box, only if it exists (legend may not be created yet)
    const box = document.getElementById("eaWarningsBox")
    const elSevere = document.getElementById("eaSevere")
    const elWarnings = document.getElementById("eaWarnings")
    const elAlerts = document.getElementById("eaAlerts")
    const elLast = document.getElementById("eaLast")

    if (elSevere) elSevere.textContent = String(nextSevere)
    if (elWarnings) elWarnings.textContent = String(nextWarnings)
    if (elAlerts) elAlerts.textContent = String(nextAlerts)

    if (elLast) {
      elLast.textContent = data?.fetchedAtEpoch
        ? new Date(data.fetchedAtEpoch * 1000).toLocaleString()
        : "Unknown"
    }

    if (box) box.style.display = "block"
  } catch (e) {
    // Keep last known value if fetch fails
  }
}
async function exportSitrepPdf() {
  const win = window.open("", "_blank")
  if (!win) {
    alert("Popup blocked. Allow popups for this site to open the SITREP.")
    return
  }

  // Optional: show something immediately so the user sees it worked
  win.document.open()
  win.document.write(`<!doctype html><html><head><meta charset="utf-8"><title>Generating SITREP</title></head>
  <body style="font-family:Arial,Helvetica,sans-serif;padding:16px">Generating SITREP...</body></html>`)
  win.document.close()

  await refreshFloodWarningsSummary()
  const rows = latestLevelRows.slice()

  const stateWeight = (s) => (s === "High" ? 3 : s === "Elevated" ? 2 : s === "Normal" ? 1 : 0)
  const freshnessWeight = (st) => (st === "Live" ? 0 : st === "Delayed" ? 1 : st === "Stale" ? 2 : 3)

  const safeText = (v) => (v === null || v === undefined ? "" : String(v))
  const esc = (s) =>
    safeText(s)
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;")

  const normaliseTrend = (t) => (t || "").toLowerCase()

  const generatedAt = new Date().toLocaleString()
  const lastRefresh = lastRefreshLocal || "Unknown"

  // Sort by severity for prioritised lists
  const severitySorted = rows
    .slice()
    .sort((a, b) => {
      const sa = stateWeight(a.item.state)
      const sb = stateWeight(b.item.state)
      if (sb !== sa) return sb - sa

      const fa = freshnessWeight(a.freshness?.status)
      const fb = freshnessWeight(b.freshness?.status)
      if (fa !== fb) return fa - fb

      return (a.item.label || "").localeCompare(b.item.label || "")
    })

  // Counts by state
  const countsByState = { High: 0, Elevated: 0, Normal: 0, "No data": 0 }
  rows.forEach((r) => {
    const st = r.item.state || "No data"
    if (countsByState[st] === undefined) countsByState["No data"] += 1
    else countsByState[st] += 1
  })

  // Freshness overview
  const countsByFreshness = { Live: 0, Delayed: 0, Stale: 0, Offline: 0, Unknown: 0 }
  rows.forEach((r) => {
    const fs = r.freshness?.status || "Unknown"
    if (countsByFreshness[fs] === undefined) countsByFreshness.Unknown += 1
    else countsByFreshness[fs] += 1
  })

  // Worst station summary
  const worstRow = severitySorted[0]
  const worstName = worstRow ? worstRow.item.label || worstRow.item.id || "" : ""
  const worstState = worstRow ? worstRow.item.state || "No data" : ""
  const worstFresh = worstRow ? worstRow.freshness?.status || "Unknown" : ""
  const worstTime = worstRow ? formatDateTime(worstRow.item.dateTime) || "" : ""
  const worstRiver = worstRow ? worstRow.item.riverName || "" : ""

  // Top stations by severity (approx top 10)
  const topStations = severitySorted.slice(0, 10)

  // Highest rising sites, using existing trend field only
  const risingSites = severitySorted
    .filter((r) => {
      const t = normaliseTrend(r.item.trend)
      return t.includes("rising") || t.includes("up") || t.includes("increasing")
    })
    .slice(0, 10)

  // River overview using existing fields only
  const riverMap = new Map()
  rows.forEach((r) => {
    const river = r.item.riverName || "Unknown river"
    const current = riverMap.get(river) || {
      river,
      total: 0,
      worst: "No data",
      high: 0,
      elevated: 0,
      normal: 0,
      nodata: 0,
    }

    current.total += 1
    const st = r.item.state || "No data"
    if (st === "High") current.high += 1
    else if (st === "Elevated") current.elevated += 1
    else if (st === "Normal") current.normal += 1
    else current.nodata += 1

    if (stateWeight(st) > stateWeight(current.worst)) current.worst = st
    riverMap.set(river, current)
  })

  const rivers = Array.from(riverMap.values()).sort((a, b) => {
    const wa = stateWeight(a.worst)
    const wb = stateWeight(b.worst)
    if (wb !== wa) return wb - wa
    return a.river.localeCompare(b.river)
  })

  // Existing hotspots already computed by dashboard logic
  const hotspots = Array.isArray(latestHotspots) ? latestHotspots : []

  // Data quality notes
  const offlineCount = countsByFreshness.Offline || 0
  const noDataCount = countsByState["No data"] || 0
  const staleOrDelayedCount = (countsByFreshness.Stale || 0) + (countsByFreshness.Delayed || 0)

  // Trend descriptor (cheap and safe)
  const trendCounts = { rising: 0, falling: 0, steady: 0, other: 0 }
  rows.forEach((r) => {
    const t = normaliseTrend(r.item.trend)
    if (t.includes("rising") || t.includes("up") || t.includes("increasing")) trendCounts.rising += 1
    else if (t.includes("falling") || t.includes("down") || t.includes("decreasing")) trendCounts.falling += 1
    else if (t.includes("steady") || t.includes("stable")) trendCounts.steady += 1
    else trendCounts.other += 1
  })

  const trendLabel = (() => {
    const total = trendCounts.rising + trendCounts.falling + trendCounts.steady + trendCounts.other
    if (!total) return "Unknown"

    // Pick the dominant trend if it is clearly dominant, otherwise Mixed
    const entries = [
      { k: "Rising", v: trendCounts.rising },
      { k: "Falling", v: trendCounts.falling },
      { k: "Steady", v: trendCounts.steady },
      { k: "Mixed/Other", v: trendCounts.other },
    ].sort((a, b) => b.v - a.v)

    const top = entries[0]
    const second = entries[1] || { v: 0 }

    // Dominant if it has at least 40% and is 1.25x the next best
    if (top.v / total >= 0.4 && top.v >= second.v * 1.25) {
      return `Predominantly ${top.k}`
    }
    return "Mixed"
  })()

  // Operational picture for SITREP Summary
  const highCount = countsByState.High || 0
  const elevCount = countsByState.Elevated || 0

  const hotspotName = hotspots.length ? hotspots[0].worst || "Unknown" : "None identified"
  const hotspotSites = hotspots.length ? hotspots[0].count || 0 : 0

  const operationalPicture = `Currently ${highCount} sites are at High state and ${elevCount} at Elevated state. Trend: ${trendLabel}. Primary area of concern: ${hotspotName}${hotspots.length ? ` (${hotspotSites} sites)` : ""}. Reporting: ${countsByFreshness.Live || 0} Live, ${countsByFreshness.Offline || 0} Offline.`

  // Full stations table, keep same as before
  const tableRows = rows
    .slice()
    .sort((a, b) => {
      const sa = stateWeight(a.item.state)
      const sb = stateWeight(b.item.state)
      if (sb !== sa) return sb - sa
      return (a.item.label || "").localeCompare(b.item.label || "")
    })
    .map((r) => {
      const it = r.item
      const fr = r.freshness
      const cls = (it.state || "No data").toLowerCase().replaceAll(" ", "-")
      const v = formatValueAndUnit(it).text
      return `<tr class="${cls}">
<td>${esc(it.label || it.id || "")}</td>
<td>${esc(it.riverName || "")}</td>
<td>${esc(v)}</td>
<td>${esc(it.trend || "")}</td>
<td>${esc(it.state || "No data")}</td>
<td>${esc(fr?.status || "")}</td>
<td>${esc(formatDateTime(it.dateTime) || "")}</td>
</tr>`
    })
    .join("")

  // Optional flood warnings summary only if already present in memory
  const floodWarningsSummary = (() => {
    const fw = window.latestFloodWarnings
    if (!fw) return null

    const normalised = { alerts: 0, warnings: 0, severe: 0 }

    if (Array.isArray(fw)) {
      fw.forEach((x) => {
        const t = (x?.type || x?.warningType || "").toLowerCase()
        if (t.includes("severe")) normalised.severe += 1
        else if (t.includes("warning")) normalised.warnings += 1
        else if (t.includes("alert")) normalised.alerts += 1
      })
      return normalised
    }

    if (typeof fw === "object") {
      normalised.alerts = Number(fw.alerts ?? fw.FloodAlert ?? fw.floodAlert ?? 0) || 0
      normalised.warnings = Number(fw.warnings ?? fw.FloodWarning ?? fw.floodWarning ?? 0) || 0
      normalised.severe = Number(fw.severe ?? fw.SevereFloodWarning ?? fw.severeFloodWarning ?? 0) || 0
      if (normalised.alerts + normalised.warnings + normalised.severe === 0) return null
      return normalised
    }

    return null
  })()

  win.document.open()
  win.document.write(`
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Staffordshire Flood SITREP</title>
<style>
  body{font-family:Arial,Helvetica,sans-serif;margin:22px;color:#111}
  .topbar{display:flex;align-items:flex-start;justify-content:space-between;gap:16px;margin-bottom:14px}
  .title{font-size:22px;font-weight:700;letter-spacing:0.2px;margin:0 0 6px 0}
  .meta{font-size:12px;color:#444;line-height:1.35}
  .logo{height:64px;object-fit:contain}

  .section{margin-top:14px;border:1px solid #d6d6d6}
  .section-h{padding:10px 12px;color:#fff;font-weight:700;font-size:14px}
  .section-c{padding:12px}

  .h-red{background:#c9091c}
  .h-green{background:#39a93a}
  .h-grey{background:#2b2b2b}

  .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  .card{border:1px solid #dcdcdc;border-radius:6px;padding:10px}
  .card h3{margin:0 0 8px 0;font-size:13px}
  .small{font-size:12px;color:#333}
  .muted{color:#555}
  .kpi{display:flex;gap:10px;flex-wrap:wrap}
  .kpi .pill{
  border:1px solid #d0d0d0;
  border-radius:999px;
  padding:6px 10px;
  font-size:12px;
  background:#fafafa;
}

.kpi .pill-alert{border-color:#c58b00;background:#fff0c7}
.kpi .pill-warning{border-color:#b85c00;background:#ffe1c2}
.kpi .pill-severe{border-color:#c9091c;background:#ffd6d6}
  .pill b{font-weight:700}
  .pill-high{border-color:#c9091c;background:#fff4f4}
  .pill-elev{border-color:#c58b00;background:#fff8e6}
  .pill-norm{border-color:#2b7a2c;background:#f0fbf0}
  .pill-data{border-color:#666;background:#f6f6f6}
  .pill-alert{border-color:#c58b00;background:#fff0c7}
  .pill-warning{border-color:#b85c00;background:#ffe1c2}
  .pill-severe{border-color:#c9091c;background:#ffd6d6}
  .pill-changed{outline:2px solid #111; outline-offset:2px}


  table{border-collapse:collapse;width:100%;font-size:12px}
  th,td{border:1px solid #cfcfcf;padding:6px;vertical-align:top}
  th{background:#f2f2f2;text-align:left}
  .tight td{padding:5px}

  tr.high{background:#ffd6d6}
  tr.elevated{background:#fff0c7}
  tr.normal{background:#e7f7e7}
  tr.no-data{background:#f2f2f2}

  .list{margin:0;padding-left:16px;font-size:12px}
  .list li{margin:4px 0}
  .badge{display:inline-block;border:1px solid #d0d0d0;border-radius:4px;padding:2px 6px;font-size:11px;background:#fafafa;margin-left:6px}
  .badge-high{border-color:#c9091c;background:#fff4f4}
  .badge-elev{border-color:#c58b00;background:#fff8e6}
  .badge-norm{border-color:#2b7a2c;background:#f0fbf0}
  .badge-data{border-color:#666;background:#f6f6f6}

  .divider{height:1px;background:#e2e2e2;margin:10px 0}

  .footer-note{margin-top:10px;font-size:11px;color:#444;border-top:1px solid #e2e2e2;padding-top:8px}

  @media print{
    body{margin:14px}
    .section{break-inside:avoid}
    table{page-break-inside:auto}
    tr{page-break-inside:avoid;page-break-after:auto}
    .card{break-inside:avoid}
  }
</style>
</head>
<body>

<div class="topbar">
  <div>
    <div class="title">Staffordshire Flood SITREP</div>
    <div class="meta">
      Generated: ${esc(generatedAt)}<br>
      Last data refresh: ${esc(lastRefresh)}
    </div>
  </div>
  <img src="/CCU.png" alt="CCU" class="logo">
</div>

<div class="section">
  <div class="section-h h-grey">SITREP Summary</div>
  <div class="section-c">
    <div class="card" style="border-radius:6px">
      <h3>Operational picture</h3>
      <div class="small">${esc(operationalPicture)}</div>
${
  window.latestFloodWarnings
    ? `<div class="divider"></div>
       <h3>Flood warnings for Staffordshire</h3>

       <div class="kpi ${window.latestFloodWarnings.changed ? "pill-changed" : ""}">
         <div class="pill pill-severe"><b>Severe Flood Warnings</b> ${Number(window.latestFloodWarnings.severe || 0)}</div>
         <div class="pill pill-warning"><b>Flood Warnings</b> ${Number(window.latestFloodWarnings.warnings || 0)}</div>
         <div class="pill pill-alert"><b>Flood Alerts</b> ${Number(window.latestFloodWarnings.alerts || 0)}</div>
       </div>

       <div class="small muted" style="margin-top:6px">
         Last EA update: ${
           window.latestFloodWarnings.fetchedAtEpoch
             ? new Date(window.latestFloodWarnings.fetchedAtEpoch * 1000).toLocaleString()
             : "Unknown"
         }
       </div>`
    : ``
}
    </div>
    <div class="footer-note">
      Automatically generated decision support product from live dashboard data. Validate key points with partner intelligence and on scene reports.
    </div>
  </div>
</div>

<div class="section">
  <div class="section-h h-red">1. Gather Information and Intelligence</div>
  <div class="section-c">

    <div class="grid">
  <div class="card">
    <h3>General operational intelligence summary</h3>
    <div class="small">
      This section provides a factual snapshot of observed river level states and reporting status derived from live dashboard feeds.
    </div>
    <div class="divider"></div>
    <div class="small">
      <b>Worst station currently:</b> ${esc(worstName)}
      <span class="badge ${worstState === "High" ? "badge-high" : worstState === "Elevated" ? "badge-elev" : worstState === "Normal" ? "badge-norm" : "badge-data"}">${esc(worstState)}</span>
      <span class="badge">${esc(worstFresh)}</span><br>
      <span class="muted">River:</span> ${esc(worstRiver || "Unknown")}<br>
      <span class="muted">Last reported:</span> ${esc(worstTime || "Unknown")}
    </div>

    <h3>Site counts by state</h3>
    <div class="kpi">
      <div class="pill pill-high"><b>High</b> ${countsByState.High}</div>
      <div class="pill pill-elev"><b>Elevated</b> ${countsByState.Elevated}</div>
      <div class="pill pill-norm"><b>Normal</b> ${countsByState.Normal}</div>
      <div class="pill pill-data"><b>No data</b> ${countsByState["No data"]}</div>
    </div>

    <div class="divider"></div>
  </div>

  <div class="card">
    <h3>Confirm river watch areas and top 3 stations</h3>

    <div class="small"><b>River watch areas (top 3)</b></div>
    ${
      rivers && rivers.length
        ? `<ol class="list" style="margin-top:6px">
            ${rivers.slice(0, 3).map((rv) => {
              const st = rv.worst || "No data"
              const badge =
                st === "High" ? "badge-high" : st === "Elevated" ? "badge-elev" : st === "Normal" ? "badge-norm" : "badge-data"
              return `<li>
                ${esc(rv.river)}
                <span class="badge ${badge}">${esc(st)}</span>
                <span class="badge">High ${Number(rv.high || 0)}</span>
                <span class="badge">Elevated ${Number(rv.elevated || 0)}</span>
              </li>`
            }).join("")}
          </ol>`
        : `<div class="small muted" style="margin-top:6px">No river grouping available.</div>`
    }

    <div class="divider"></div>

    <div class="small"><b>Top 3 stations to confirm</b></div>
    ${
      topStations && topStations.length
        ? `<ol class="list" style="margin-top:6px">
            ${topStations.slice(0, 3).map((r) => {
              const it = r.item
              const st = it.state || "No data"
              const badge =
                st === "High" ? "badge-high" : st === "Elevated" ? "badge-elev" : st === "Normal" ? "badge-norm" : "badge-data"
              return `<li>
                ${esc(it.label || it.id || "")}
                <span class="badge ${badge}">${esc(st)}</span>
                ${it.riverName ? `<span class="badge">${esc(it.riverName)}</span>` : ""}
                ${r.freshness?.status ? `<span class="badge">${esc(r.freshness.status)}</span>` : ""}
              </li>`
            }).join("")}
          </ol>`
        : `<div class="small muted" style="margin-top:6px">No station data available.</div>`
    }

    <div class="small muted" style="margin-top:8px">
      Confirm impacts with partner intelligence and local observation, especially where reporting is Delayed, Stale, or Offline.
    </div>
  </div>
</div>

    <div class="grid" style="margin-top:12px">
      <div class="card">
        <h3>Top stations by severity (approx top 10)</h3>
        ${
          topStations.length
            ? `<table class="tight">
                <tr>
                  <th>Station</th>
                  <th>River</th>
                  <th>Status</th>
                  <th>Reporting</th>
                  <th>Time</th>
                </tr>
                ${topStations
                  .map((r) => {
                    const it = r.item
                    const st = it.state || "No data"
                    const badge =
                      st === "High" ? "badge-high" : st === "Elevated" ? "badge-elev" : st === "Normal" ? "badge-norm" : "badge-data"
                    return `<tr>
                      <td>${esc(it.label || it.id || "")}</td>
                      <td>${esc(it.riverName || "")}</td>
                      <td><span class="badge ${badge}">${esc(st)}</span></td>
                      <td>${esc(r.freshness?.status || "")}</td>
                      <td>${esc(formatDateTime(it.dateTime) || "")}</td>
                    </tr>`
                  })
                  .join("")}
              </table>`
            : `<div class="small">No station data available.</div>`
        }
      </div>

      <div class="card">
        <h3>River levels and their status</h3>
        ${
          rivers.length
            ? `<table class="tight">
                <tr>
                  <th>River</th>
                  <th>Worst</th>
                  <th>High</th>
                  <th>Elevated</th>
                  <th>Normal</th>
                  <th>No data</th>
                  <th>Total</th>
                </tr>
                ${rivers
                  .slice(0, 12)
                  .map((rv) => {
                    const st = rv.worst || "No data"
                    const badge =
                      st === "High" ? "badge-high" : st === "Elevated" ? "badge-elev" : st === "Normal" ? "badge-norm" : "badge-data"
                    return `<tr>
                      <td>${esc(rv.river)}</td>
                      <td><span class="badge ${badge}">${esc(st)}</span></td>
                      <td>${rv.high}</td>
                      <td>${rv.elevated}</td>
                      <td>${rv.normal}</td>
                      <td>${rv.nodata}</td>
                      <td>${rv.total}</td>
                    </tr>`
                  })
                  .join("")}
              </table>
              <div class="small muted" style="margin-top:6px">Showing up to 12 rivers by worst status.</div>`
            : `<div class="small">No river grouping available.</div>`
        }
      </div>
    </div>

    <div class="grid" style="margin-top:12px">
      <div class="card">
        <h3>Worst station summary</h3>
        <div class="small">
          <b>Station:</b> ${esc(worstName)}<br>
          <b>River:</b> ${esc(worstRiver || "Unknown")}<br>
          <b>Status:</b> ${esc(worstState)}<br>
          <b>Reporting:</b> ${esc(worstFresh)}<br>
          <b>Time:</b> ${esc(worstTime || "Unknown")}
        </div>
      </div>

      <div class="card">
        <h3>Data quality notes</h3>
        <ul class="list">
          <li>Offline sites: <b>${offlineCount}</b></li>
          <li>Sites with no data/state: <b>${noDataCount}</b></li>
          <li>Delayed or stale readings: <b>${staleOrDelayedCount}</b></li>
        </ul>
        <div class="small muted" style="margin-top:6px">
          Notes are generated from current dashboard reading states and freshness flags.
        </div>
      </div>
    </div>

  </div>
</div>

<div class="section">
  <div class="section-h h-green">2. Assess threats and risks and develop a working strategy</div>
  <div class="section-c">

    <div class="grid">
      <div class="card">
        <h3>Areas for concern (top ranked stations)</h3>
        ${
          topStations.length
            ? `<ol class="list">
                ${topStations
                  .slice(0, 8)
                  .map((r) => {
                    const it = r.item
                    const st = it.state || "No data"
                    const badge =
                      st === "High" ? "badge-high" : st === "Elevated" ? "badge-elev" : st === "Normal" ? "badge-norm" : "badge-data"
                    return `<li>
                      ${esc(it.label || it.id || "")}
                      <span class="badge ${badge}">${esc(st)}</span>
                      ${it.riverName ? `<span class="badge">${esc(it.riverName)}</span>` : ""}
                      ${r.freshness?.status ? `<span class="badge">${esc(r.freshness.status)}</span>` : ""}
                    </li>`
                  })
                  .join("")}
              </ol>`
            : `<div class="small">No prioritised stations available.</div>`
        }
        <div class="small muted" style="margin-top:6px">
          Ranked using current station state and reporting freshness only.
        </div>
      </div>

      <div class="card">
        <h3>Highest rising sites</h3>
        ${
          risingSites.length
            ? `<ol class="list">
                ${risingSites
                  .map((r) => {
                    const it = r.item
                    const st = it.state || "No data"
                    const badge =
                      st === "High" ? "badge-high" : st === "Elevated" ? "badge-elev" : st === "Normal" ? "badge-norm" : "badge-data"
                    return `<li>
                      ${esc(it.label || it.id || "")}
                      <span class="badge ${badge}">${esc(st)}</span>
                      ${esc(it.trend || "") ? `<span class="badge">${esc(it.trend)}</span>` : ""}
                      ${it.riverName ? `<span class="badge">${esc(it.riverName)}</span>` : ""}
                    </li>`
                  })
                  .join("")}
              </ol>`
            : `<div class="small">No rising trend indicators available.</div>`
        }
        <div class="small muted" style="margin-top:6px">
          Uses existing trend text already shown in the dashboard table.
        </div>
      </div>
    </div>

    <div class="grid" style="margin-top:12px">
      <div class="card">
        <h3>Clusters or hotspots of concern</h3>
        ${
          hotspots && hotspots.length
            ? `<table class="tight">
                <tr>
                  <th>Rank</th>
                  <th>Hotspot</th>
                  <th>Sites</th>
                </tr>
                ${hotspots
                  .slice(0, 10)
                  .map((h, i) => {
                    return `<tr>
                      <td>${i + 1}</td>
                      <td>${esc(h.worst || "")}</td>
                      <td>${esc(h.count || "")}</td>
                    </tr>`
                  })
                  .join("")}
              </table>`
            : `<div class="small">None identified by current dashboard logic.</div>`
        }
        <div class="small muted" style="margin-top:6px">
          Hotspots are taken directly from the dashboard hotspot list.
        </div>
      </div>

      <div class="card">
        <h3>Other prioritisation indicators</h3>
        <ul class="list">
          <li>Focus on stations in <b>High</b> and <b>Elevated</b> states that are <b>Delayed</b>, <b>Stale</b>, or <b>Offline</b>.</li>
          <li>Use hotspot clusters to confirm whether issues are isolated or geographically concentrated.</li>
          <li>Where reporting is degraded, consider corroboration through local observation and partner reports.</li>
        </ul>
        <div class="small muted" style="margin-top:6px">
          This guidance is static wording only. It does not introduce new dashboard logic.
        </div>
      </div>
    </div>

  </div>
</div>

<div class="section" style="margin-top:14px">
  <div class="section-h h-grey">Stations (full list)</div>
  <div class="section-c">
    <table>
      <tr>
        <th>Station</th>
        <th>River</th>
        <th>Level</th>
        <th>Trend</th>
        <th>Status</th>
        <th>Reporting</th>
        <th>Time</th>
      </tr>
      ${tableRows}
    </table>
  </div>
</div>
<div class="footer-note" style="margin-top:14px">
  Source: Environment Agency Flood Monitoring API
</div>
</body>
</html>
`)

  win.document.close()
}
/* ------------------------------------------------------------
   Modal + buttons
   ------------------------------------------------------------ */

const modalBack = document.getElementById("tableModalBack")

document.getElementById("btnTable")?.addEventListener("click", () => {
    if (!modalBack) return
    modalBack.style.display = "flex"
    renderTable()
})

document.getElementById("btnCloseTable")?.addEventListener("click", () => {
    if (!modalBack) return
    modalBack.style.display = "none"
})

modalBack?.addEventListener("click", (e) => {
    if (e.target === modalBack) modalBack.style.display = "none"
})

document.getElementById("tableSearch")?.addEventListener("input", () => {
    renderTable()
})

document.getElementById("btnCsv")?.addEventListener("click", exportCsvFromTable)
document.getElementById("btnPdf")?.addEventListener("click", () => {
    if (!latestLevelRows || latestLevelRows.length === 0) {
        alert("Data is still loading, wait a moment then try again.")
        return
    }
    exportSitrepPdf()
})

document.getElementById("btnWorst")?.addEventListener("click", () => {
    if (!worstStation) return
    zoomToStation(worstStation.id)
})

document.getElementById("btnRadar")?.addEventListener("click", toggleRadar)
document.getElementById("btnWarnings")?.addEventListener("click", toggleWarnings)
document.getElementById("btnCatchments")?.addEventListener("click", toggleCatchments)
document.getElementById("btnDistricts")?.addEventListener("click", toggleDistricts)
document.getElementById("btnRivers")?.addEventListener("click", toggleRiverLabels)

document.getElementById("markerMode")?.addEventListener("change", (e) => {
    markerMode = e.target.value || "all"
    applyMarkerMode()
})

/* ------------------------------------------------------------
   Data loading
   ------------------------------------------------------------ */

async function loadBoundary() {
    try {
        const res = await fetch("/staffordshire/boundary", { cache: "no-store" })
        if (!res.ok) throw new Error(`boundary ${res.status}`)
        const geojson = await res.json()

        if (boundaryLayer) map.removeLayer(boundaryLayer)

        boundaryLayer = L.geoJSON(geojson, {
            pane: "polygonsPane",
            style: { color: "#111111", weight: 2, fillOpacity: 0 }
        }).addTo(map)

        // Optional: zoom map to boundary once loaded
        try { map.fitBounds(boundaryLayer.getBounds(), { padding: [12, 12] }) } catch (e) {}
    } catch (e) {
        console.error("loadBoundary failed:", e)
    }
}

async function loadStations() {
    try {
        const res = await fetch("/staffordshire/stations", { cache: "no-store" })
        if (!res.ok) throw new Error(`stations ${res.status}`)
        const data = await res.json()

        Object.keys(markers).forEach(id => {
            try { map.removeLayer(markers[id]) } catch (e) {}
        })
        markers = {}

        ;(data.stations || []).forEach(st => {
            if (st.lat == null || st.long == null) return
            const marker = L.circleMarker([st.lat, st.long], markerBaseStyle())
            marker.addTo(map)
            marker.bindPopup("Loading...")
            markers[st.id] = marker
        })

        applyMarkerMode()
    } catch (e) {
        console.error("loadStations failed:", e)
    }
}

async function fetchStatusPage(offset, limit) {
    const url = `/staffordshire/status?offset=${offset}&limit=${limit}`
    const res = await fetch(url, { cache: "no-store", credentials: "same-origin" })

    if (res.status === 401) {
        console.error("401 Unauthorised for", url)
        throw new Error("401 Unauthorised")
    }

    if (!res.ok) throw new Error(`status ${res.status}`)
    return res.json()
}
/* ADD THIS FUNCTION */
async function refreshStatusAll() {
    let offset = 0
    let combined = []

    while (true) {
    const page = await fetchStatusPage(offset, PAGE_LIMIT)
    const items = page.items || []

    // APPLY MARKER UPDATES IMMEDIATELY
    items.forEach(item => {
        const m = markers[item.id]
        if (!m) return
        const freshness = classifyFreshness(item.dateTime)
        const colour = stateToColour(item.state)
        setMarkerStyle(m, colour)
        m.setPopupContent(buildPopup(item, freshness))
    })

    combined = combined.concat(items)
    if (items.length < PAGE_LIMIT) break
    offset += PAGE_LIMIT
    }

    await refreshFloodWarningsSummary()
    
    latestItemsById = {}
    latestLevelRows = []

    const counts = { high: 0, elevated: 0, normal: 0, delayed: 0, stale: 0, offline: 0, nodata: 0 }
    let risingCount = 0
    let offlineCount = 0

    combined.forEach(item => {
        if (!item || !item.id) return
        latestItemsById[item.id] = item

        const freshness = classifyFreshness(item.dateTime)
        const m = markers[item.id]

        const isLevel = (item.parameter || "").toLowerCase() === "level" || (item.unitShort || "").toLowerCase() === "m"

        if (isLevel) {
            latestLevelRows.push({ item, freshness })
        }

        const colour = stateToColour(item.state)
        if (m) {
            setMarkerStyle(m, colour)
            m.setPopupContent(buildPopup(item, freshness))
        }

        const rep = freshness.status
        const st = item.state || "NoData"

        if (rep === "Delayed") counts.delayed += 1
        else if (rep === "Stale") counts.stale += 1
        else if (rep === "Offline") counts.offline += 1

        if (st === "High") counts.high += 1
        else if (st === "Elevated") counts.elevated += 1
        else if (st === "Normal") counts.normal += 1
        else counts.nodata += 1

        if (item.trend === "Rising") risingCount += 1
        if (rep === "Offline") offlineCount += 1
    })

    latestLevelRows.sort((a, b) => {
        const an = (a.item.label || a.item.id || "")
        const bn = (b.item.label || b.item.id || "")
        return an.localeCompare(bn)
    })

    latestHotspots = buildHotspots(latestLevelRows)
    updateHotspotPanel()

    const attention = computeAttention(latestLevelRows)
    updateAttentionPanel(attention)

    const snap = makeSnapshot(latestLevelRows)
    const delta = summariseDelta(previousSnapshotById, snap)
    updateDeltaPanel(delta)
    previousSnapshotById = snap

    requestAnimationFrame(() => {
    try { applyPulseToFastestRising(latestLevelRows) } catch (e) {}
    })

    worstStation = null
    let bestScore = -1
    latestLevelRows.forEach(r => {
        const s = worstScore(r.item, r.freshness)
        if (s > bestScore) {
            bestScore = s
            worstStation = r.item
        }
    })

    setIntel("intelWorst", worstStation ? (worstStation.label || worstStation.id) : "Unknown")
    setIntel("intelRising", risingCount)
    setIntel("intelOffline", offlineCount)

    lastRefreshLocal = new Date().toLocaleString()
    setIntel("intelLast", lastRefreshLocal)

    updateLegendCounts(counts)

    if (modalBack && modalBack.style.display === "flex") {
        renderTable()
    }
    applyMarkerMode()
}
/* ------------------------------------------------------------
   Init
   ------------------------------------------------------------ */

async function init() {
    await loadBoundary()
    await loadStations()
    await refreshStatusAll()

    setInterval(async () => {
        try { await refreshStatusAll() } catch (e) {}
    }, REFRESH_MS)
}

init()
</script>

</body>
</html>
