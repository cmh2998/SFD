<!-- templates/index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Staffordshire Flood Dashboard</title>

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>

    <style>
        body { margin: 0; font-family: Arial, Helvetica, sans-serif; background: #f2f2f2; }

        #header {
            background: #1f3a5f;
            color: white;
            padding: 12px 18px;
            font-size: 20px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }

        #header .controls { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }

        #header button, #header select {
            background: rgba(255,255,255,0.12);
            color: white;
            border: 1px solid rgba(255,255,255,0.25);
            border-radius: 6px;
            padding: 6px 10px;
            cursor: pointer;
            font-size: 13px;
        }

        #header button:hover { background: rgba(255,255,255,0.18); }

        #map { height: calc(100vh - 58px); width: 100%; }

        .legend {
            background: white;
            padding: 10px 12px;
            line-height: 1.5;
            box-shadow: 0 0 8px rgba(0,0,0,0.2);
            border-radius: 6px;
            font-size: 13px;
            min-width: 240px;
        }

        .legend h4 { margin: 0 0 8px 0; font-size: 14px; }

        .legend .row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            margin: 4px 0;
        }

        .legend .left { display: flex; align-items: center; gap: 8px; }

        .swatch {
            width: 12px; height: 12px; border-radius: 50%;
            display: inline-block; border: 1px solid rgba(0,0,0,0.25);
        }

        .muted { opacity: 0.65; }
        .small { font-size: 12px; color: #333; }
        .tiny { font-size: 11px; color: #555; }

        .panel {
            background: white;
            padding: 10px 12px;
            line-height: 1.4;
            box-shadow: 0 0 8px rgba(0,0,0,0.2);
            border-radius: 6px;
            font-size: 13px;
            min-width: 340px;
            max-width: 380px;
        }

        .panel h4 { margin: 0 0 8px 0; font-size: 14px; }
        .panel .item { margin: 6px 0; }

        .panel .pill {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 999px;
            font-size: 12px;
            border: 1px solid rgba(0,0,0,0.15);
            background: #f7f7f7;
            max-width: 100%;
            overflow-wrap: anywhere;
        }

        .panel .pill.pillGreen { background: rgba(26,150,65,0.12); border-color: rgba(26,150,65,0.35); }
        .panel .pill.pillAmber { background: rgba(253,174,97,0.18); border-color: rgba(253,174,97,0.55); }
        .panel .pill.pillRed { background: rgba(215,25,28,0.12); border-color: rgba(215,25,28,0.35); }
        .panel .pill.pillHotGreen { background: rgba(26,150,65,0.18); border-color: rgba(26,150,65,0.55); }
        .panel .pill.pillHotAmber { background: rgba(253,174,97,0.22); border-color: rgba(253,174,97,0.65); }
        .panel .pill.pillHotRed { background: rgba(215,25,28,0.18); border-color: rgba(215,25,28,0.55); }

        .panel .section { margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(0,0,0,0.1); }

        .panel .hotspotRow, .panel .attentionRow {
            display: flex; align-items: center; justify-content: space-between;
            gap: 8px; margin: 6px 0;
        }

        .panel .hotspotLink {
            cursor: pointer; text-decoration: underline; color: #1f3a5f; font-size: 12px;
            user-select: none;
        }

        /* Table modal */
        .modalBack {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.45);
            display: none;
            align-items: center;
            justify-content: center;
            padding: 18px;
            z-index: 9999;
        }

        .modal {
            width: min(1100px, 100%);
            max-height: min(80vh, 900px);
            background: white;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0,0,0,0.35);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .modalHeader {
            background: #1f3a5f;
            color: white;
            padding: 10px 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }

        .modalHeader .title { font-weight: bold; }

        .modalHeader .actions { display: flex; gap: 8px; align-items: center; }

        .modalHeader button {
            background: rgba(255,255,255,0.12);
            color: white;
            border: 1px solid rgba(255,255,255,0.25);
            border-radius: 6px;
            padding: 6px 10px;
            cursor: pointer;
            font-size: 13px;
        }

        .modalBody { padding: 10px 12px; overflow: auto; }

        .tableWrap { overflow: auto; border: 1px solid rgba(0,0,0,0.12); border-radius: 8px; }

        table { width: 100%; border-collapse: collapse; font-size: 13px; }

        th, td {
            text-align: left;
            padding: 8px 10px;
            border-bottom: 1px solid rgba(0,0,0,0.08);
            white-space: nowrap;
        }

        th { position: sticky; top: 0; background: #fafafa; z-index: 2; }
        tr:hover td { background: #fcfcfc; }

        .tag {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 999px;
            font-size: 12px;
            border: 1px solid rgba(0,0,0,0.15);
        }

        .tagHigh { background: rgba(215,25,28,0.12); border-color: rgba(215,25,28,0.35); }
        .tagElevated { background: rgba(253,174,97,0.18); border-color: rgba(253,174,97,0.55); }
        .tagNormal { background: rgba(26,150,65,0.12); border-color: rgba(26,150,65,0.35); }
        .tagNoData { background: rgba(153,153,153,0.15); border-color: rgba(153,153,153,0.45); }

        .tagLive { background: rgba(26,150,65,0.10); border-color: rgba(26,150,65,0.25); }
        .tagDelayed { background: rgba(44,123,182,0.10); border-color: rgba(44,123,182,0.25); }
        .tagStale { background: rgba(123,50,148,0.10); border-color: rgba(123,50,148,0.25); }
        .tagOffline { background: rgba(119,119,119,0.10); border-color: rgba(119,119,119,0.25); }

        .searchRow { display: flex; gap: 10px; align-items: center; margin: 0 0 10px 0; }

        .searchRow input {
            flex: 1;
            padding: 8px 10px;
            border-radius: 8px;
            border: 1px solid rgba(0,0,0,0.18);
            font-size: 13px;
        }

        .searchRow .hint { font-size: 12px; color: #555; }

        /* Pulse marker */
        .pulse {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            position: relative;
            pointer-events: none;
        }
        .pulse::after {
            content: "";
            position: absolute;
            left: 50%;
            top: 50%;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: pulse 1.8s infinite;
            opacity: 0.6;
            background: var(--pulse-colour);
        }

        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 0.7; }
            100% { transform: translate(-50%, -50%) scale(3.2); opacity: 0; }
        }
    </style>
</head>

<body>
<div id="header">
    <div>Staffordshire Flood Dashboard</div>
    <div class="controls">
        <select id="markerMode" title="Marker mode">
            <option value="all">Markers: All</option>
            <option value="level">Markers: Level only</option>
            <option value="rainfall">Markers: Rainfall only</option>
        </select>

        <button id="btnTable">Table view</button>
        <button id="btnPdf">SITREP</button>
        <button id="btnWorst">Zoom to worst</button>

        <button id="btnRadar">Radar</button>
        <button id="btnWarnings">Flood warnings</button>
        <button id="btnCatchments">Catchments</button>
        <button id="btnRivers">River labels</button>
    </div>
</div>

<div id="map"></div>

<!-- Table modal -->
<div id="tableModalBack" class="modalBack">
    <div class="modal">
        <div class="modalHeader">
            <div class="title">Table view (level stations only)</div>
            <div class="actions">
                <button id="btnCsv">Export CSV</button>
                <button id="btnCloseTable">Close</button>
            </div>
        </div>
        <div class="modalBody">
            <div class="searchRow">
                <input id="tableSearch" type="text" placeholder="Search station name...">
                <div class="hint">Filters the rows below</div>
            </div>
            <div class="tableWrap">
                <table id="stationsTable">
                    <thead>
                        <tr>
                            <th>Station</th>
                            <th>Level</th>
                            <th>Trend</th>
                            <th>State</th>
                            <th>Reporting</th>
                            <th>Reading time</th>
                            <th>Age</th>
                        </tr>
                    </thead>
                    <tbody id="stationsTableBody">
                        <tr><td colspan="7">Loading...</td></tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
/* ------------------------------------------------------------
   Settings
   ------------------------------------------------------------ */
const REFRESH_MS = 2 * 60 * 1000
const PAGE_LIMIT = 25

const THRESHOLDS = {
    liveHours: 12,
    delayedHours: 48,
    staleHours: 168
}

const COLOURS = {
    high: "#d7191c",
    elevated: "#fdae61",
    normal: "#1a9641",
    delayed: "#2c7bb6",
    stale: "#7b3294",
    offline: "#777777",
    nodata: "#999999"
}

const HOTSPOT_RADIUS_KM = 5
const HOTSPOT_MIN_POINTS = 2
const BASELINE_KEY = "sfdb_sitrep_baseline_v1"

/* ------------------------------------------------------------
   Map init + panes
   ------------------------------------------------------------ */
const map = L.map("map").setView([52.9, -2.05], 9)

L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    attribution: "&copy; OpenStreetMap contributors"
}).addTo(map)

/*
CircleMarkers live in the SVG overlay by default, same as polygons
That means catchments can sit on top and steal clicks
Fix: give stations their own higher pane, and catchments a lower pane
*/
map.createPane("polygonsPane")
map.getPane("polygonsPane").style.zIndex = 420

map.createPane("labelsPane")
map.getPane("labelsPane").style.zIndex = 630

map.createPane("stationsPane")
map.getPane("stationsPane").style.zIndex = 650

map.createPane("pulsePane")
map.getPane("pulsePane").style.zIndex = 640
map.getPane("pulsePane").style.pointerEvents = "none"

/* ------------------------------------------------------------
   State
   ------------------------------------------------------------ */
let boundaryLayer = null
let markers = {}
let stationsLoaded = false
let lastRefreshLocal = null

let latestItemsById = {}
let latestLevelRows = []
let previousSnapshotById = null
let latestHotspots = []
let worstStation = null

let radarLayer = null
let radarOn = false

let warningsLayer = null
let warningsOn = false

let catchmentsLayer = null
let catchmentsOn = false

let riverLabelsLayer = null
let riverLabelsOn = false

let markerMode = "all"

let pulseMarkers = {}
function applyMarkerMode() {
    const want = markerMode || "all"
    // Hide pulse markers when not showing level markers
    const hidePulses = (want === "rainfall")
    Object.keys(pulseMarkers).forEach(id => {
    const pm = pulseMarkers[id]
    if (!pm) return
    if (hidePulses) {
        if (map.hasLayer(pm)) map.removeLayer(pm)
    } else {
        if (!map.hasLayer(pm)) pm.addTo(map)
    }
    })

    Object.keys(markers).forEach(id => {
        const m = markers[id]
        const item = latestItemsById[id]

        // If we do not have status for this marker yet, leave it visible
        if (!item) {
            if (!map.hasLayer(m)) m.addTo(map)
            return
        }

        const p = (item.parameter || "").toLowerCase()
        const u = (item.unitShort || "").toLowerCase()

        const isLevel = p === "level" || u === "m"
        const isRain = p === "rainfall" || u === "mm"

        let show = true
        if (want === "level") show = isLevel
        if (want === "rainfall") show = isRain

        if (show) {
            if (!map.hasLayer(m)) m.addTo(map)
        } else {
            if (map.hasLayer(m)) map.removeLayer(m)
        }
    })
}
function nowMs() { return Date.now() }

function parseIsoMs(iso) {
    if (!iso) return null
    const d = new Date(iso)
    const t = d.getTime()
    if (Number.isNaN(t)) return null
    return t
}

function formatDateTime(iso) {
    if (!iso) return "Unknown"
    return iso.replace("T", " ").replace("Z", "")
}

function formatAge(ms) {
    if (ms == null) return "Unknown"
    const totalSeconds = Math.max(0, Math.floor(ms / 1000))
    const mins = Math.floor(totalSeconds / 60)
    const hours = Math.floor(mins / 60)
    const days = Math.floor(hours / 24)

    const remHours = hours % 24
    const remMins = mins % 60

    if (days > 0) return `${days}d ${remHours}h`
    if (hours > 0) return `${hours}h ${remMins}m`
    return `${mins}m`
}

function classifyFreshness(dateTimeIso) {
    const t = parseIsoMs(dateTimeIso)
    if (t == null) return { status: "Offline", ageMs: null }

    const ageMs = nowMs() - t
    const ageHours = ageMs / (1000 * 60 * 60)

    if (ageHours <= THRESHOLDS.liveHours) return { status: "Live", ageMs }
    if (ageHours <= THRESHOLDS.delayedHours) return { status: "Delayed", ageMs }
    if (ageHours <= THRESHOLDS.staleHours) return { status: "Stale", ageMs }
    return { status: "Offline", ageMs }
}

function stateToColour(state) {
    if (state === "High") return COLOURS.high
    if (state === "Elevated") return COLOURS.elevated
    if (state === "Normal") return COLOURS.normal
    if (state === "NoData") return COLOURS.nodata
    return COLOURS.nodata
}

function markerBaseStyle() {
    return { radius: 6, color: "#666", fillColor: "#999", fillOpacity: 0.7, weight: 2, opacity: 1, pane: "stationsPane" }
}

function setMarkerStyle(marker, colour, opts) {
    const extra = opts || {}
    marker.setStyle({
        color: colour,
        fillColor: colour,
        fillOpacity: extra.fillOpacity != null ? extra.fillOpacity : 0.75,
        opacity: extra.opacity != null ? extra.opacity : 1,
        weight: extra.weight != null ? extra.weight : 2
    })
}

function formatValueAndUnit(item) {
    const v = item.value
    const u = item.unitShort || item.unit || ""
    if (v == null) return { label: "Value", text: "Unknown" }

    const unitText = u ? ` ${u}` : ""
    const p = (item.parameter || "").toLowerCase()
    const isLevel = p === "level" || (u || "").toLowerCase() === "m"

    if (isLevel) return { label: "Level", text: `${v}${unitText}` }
    return { label: "Value", text: `${v}${unitText}` }
}

function escapeHtml(s) {
    return String(s)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;")
}

function buildPopup(item, freshness) {
    const ageText = freshness.ageMs == null ? "Unknown" : formatAge(freshness.ageMs)
    const v = formatValueAndUnit(item)

    const district = item.district ? `District: ${escapeHtml(item.district)}<br>` : ""
    const river = item.riverName ? `River: ${escapeHtml(item.riverName)}<br>` : ""
    const catchment = item.catchmentName ? `Catchment: ${escapeHtml(item.catchmentName)}<br>` : ""

    return `
        <b>${escapeHtml(item.label || item.id)}</b><br>
        ${district}
        ${river}
        ${catchment}
        ${v.label}: ${escapeHtml(v.text)}<br>
        Trend: ${escapeHtml(item.trend || "Unknown")}<br>
        State: ${escapeHtml(item.state || "Unknown")}<br>
        Reporting: ${escapeHtml(freshness.status)}<br>
        Reading time: ${escapeHtml(formatDateTime(item.dateTime) || "Unknown")}<br>
        Age: ${escapeHtml(ageText)}
    `
}

/* ------------------------------------------------------------
   Legend + intel panels
   ------------------------------------------------------------ */
function createLegendControl() {
    const legend = L.control({ position: "bottomleft" })

    legend.onAdd = function() {
        const div = L.DomUtil.create("div", "legend")
        div.innerHTML = `
            <h4>Status</h4>

            <div class="row"><div class="left"><span class="swatch" style="background:${COLOURS.high}"></span>High</div><div><b id="countHigh">0</b></div></div>
            <div class="row"><div class="left"><span class="swatch" style="background:${COLOURS.elevated}"></span>Elevated</div><div><b id="countElevated">0</b></div></div>
            <div class="row"><div class="left"><span class="swatch" style="background:${COLOURS.normal}"></span>Normal</div><div><b id="countNormal">0</b></div></div>
            <div class="row"><div class="left"><span class="swatch" style="background:${COLOURS.delayed}"></span>Delayed</div><div><b id="countDelayed">0</b></div></div>
            <div class="row"><div class="left"><span class="swatch" style="background:${COLOURS.stale}"></span>Stale</div><div><b id="countStale">0</b></div></div>
            <div class="row"><div class="left"><span class="swatch" style="background:${COLOURS.offline}"></span>Offline</div><div><b id="countOffline">0</b></div></div>
            <div class="row"><div class="left"><span class="swatch muted" style="background:${COLOURS.nodata}"></span>No data</div><div><b id="countNoData">0</b></div></div>

            <hr>

            <div class="small">Last refreshed: <b id="lastRef">Never</b></div>
            <div class="tiny">
                Reading freshness: Live ≤ ${THRESHOLDS.liveHours}h, Delayed ≤ ${THRESHOLDS.delayedHours}h, Stale ≤ ${THRESHOLDS.staleHours}h, Offline &gt; ${THRESHOLDS.staleHours}h
            </div>
        `
        return div
    }

    legend.addTo(map)
}

function createIntelPanel() {
    const panel = L.control({ position: "topright" })

    panel.onAdd = function() {
        const div = L.DomUtil.create("div", "panel")
        div.innerHTML = `
            <h4>Intelligence</h4>

            <div class="item">Highest risk: <span class="pill" id="intelWorst">Unknown</span></div>
            <div class="item">Rising level sites: <span class="pill" id="intelRising">0</span></div>
            <div class="item">Offline sites: <span class="pill" id="intelOffline">0</span></div>
            <div class="item">Last update: <span class="pill" id="intelLast">Never</span></div>

            <div class="section">
                <div class="item"><b>Hotspots (within ${HOTSPOT_RADIUS_KM} km)</b></div>
                <div id="hotspotList" class="tiny">None</div>
            </div>

            <div class="section">
                <div class="item"><b>Areas of interest</b></div>
                <div id="attentionList" class="tiny">None</div>
            </div>

            <div class="section">
                <div class="item"><b>Changes since last refresh</b></div>
                <div class="tiny" id="deltaSummary">No previous snapshot yet</div>
            </div>

            <div class="tiny">Highest risk uses State then freshness then trend, plus missing data penalty.</div>
        `
        return div
    }

    panel.addTo(map)
}

createLegendControl()
createIntelPanel()

function updateLegendCounts(counts) {
    const set = (id, val) => {
        const el = document.getElementById(id)
        if (el) el.textContent = String(val)
    }

    set("countHigh", counts.high)
    set("countElevated", counts.elevated)
    set("countNormal", counts.normal)
    set("countDelayed", counts.delayed)
    set("countStale", counts.stale)
    set("countOffline", counts.offline)
    set("countNoData", counts.nodata)

    const last = document.getElementById("lastRef")
    if (last) last.textContent = lastRefreshLocal ? lastRefreshLocal : "Never"
}

function setIntel(id, text) {
    const el = document.getElementById(id)
    if (el) el.textContent = String(text)
}

function worstScore(item, freshness) {
    let score = 0

    if (item.state === "High") score += 300
    else if (item.state === "Elevated") score += 200
    else if (item.state === "Normal") score += 100

    if (freshness.status === "Delayed") score += 30
    else if (freshness.status === "Stale") score += 60
    else if (freshness.status === "Offline") score += 90

    if (item.trend === "Rising") score += 15
    else if (item.trend === "Falling") score += 5

    if (item.value == null || item.dateTime == null) score += 120

    return score
}

/* ------------------------------------------------------------
   Table
   ------------------------------------------------------------ */
function downloadText(filename, text, mime) {
    const blob = new Blob([text], { type: mime || "text/plain" })
    const url = URL.createObjectURL(blob)
    const a = document.createElement("a")
    a.href = url
    a.download = filename
    document.body.appendChild(a)
    a.click()
    a.remove()
    URL.revokeObjectURL(url)
}

function csvEscape(v) {
    const s = String(v ?? "")
    if (s.includes(",") || s.includes('"') || s.includes("\n")) {
        return `"${s.replaceAll('"', '""')}"`
    }
    return s
}

function tagClassForState(state) {
    if (state === "High") return "tag tagHigh"
    if (state === "Elevated") return "tag tagElevated"
    if (state === "Normal") return "tag tagNormal"
    return "tag tagNoData"
}

function tagClassForFreshness(status) {
    if (status === "Live") return "tag tagLive"
    if (status === "Delayed") return "tag tagDelayed"
    if (status === "Stale") return "tag tagStale"
    return "tag tagOffline"
}

function renderTable() {
    const body = document.getElementById("stationsTableBody")
    const q = (document.getElementById("tableSearch")?.value || "").trim().toLowerCase()
    if (!body) return

    const rows = latestLevelRows.filter(r => {
        if (!q) return true
        const name = (r.item.label || r.item.id || "").toLowerCase()
        return name.includes(q)
    })

    if (!rows.length) {
        body.innerHTML = `<tr><td colspan="7">No matching stations</td></tr>`
        return
    }

    body.innerHTML = rows.map(r => {
        const item = r.item
        const freshness = r.freshness

        const v = formatValueAndUnit(item)
        const ageText = freshness.ageMs == null ? "Unknown" : formatAge(freshness.ageMs)

        const stateTag = `<span class="${tagClassForState(item.state)}">${escapeHtml(item.state || "NoData")}</span>`
        const repTag = `<span class="${tagClassForFreshness(freshness.status)}">${escapeHtml(freshness.status)}</span>`

        return `
            <tr>
                <td>${escapeHtml(item.label || item.id || "")}</td>
                <td>${escapeHtml(v.text)}</td>
                <td>${escapeHtml(item.trend || "Unknown")}</td>
                <td>${stateTag}</td>
                <td>${repTag}</td>
                <td>${escapeHtml(formatDateTime(item.dateTime))}</td>
                <td>${escapeHtml(ageText)}</td>
            </tr>
        `
    }).join("")
}

function exportCsvFromTable() {
    const rows = latestLevelRows.map(r => {
        const item = r.item
        const freshness = r.freshness
        const v = formatValueAndUnit(item)
        const ageText = freshness.ageMs == null ? "Unknown" : formatAge(freshness.ageMs)
        return [
            item.label || item.id || "",
            v.text,
            item.trend || "",
            item.state || "",
            freshness.status || "",
            formatDateTime(item.dateTime) || "",
            ageText
        ]
    })

    const header = ["Station", "Level", "Trend", "State", "Reporting", "Reading time", "Age"]
    const lines = [header, ...rows].map(r => r.map(csvEscape).join(",")).join("\n")
    const stamp = new Date().toISOString().replaceAll(":", "").replaceAll("-", "").slice(0, 15)
    downloadText(`staffordshire_levels_${stamp}.csv`, lines, "text/csv")
}

/* ------------------------------------------------------------
   Hotspot detection
   ------------------------------------------------------------ */
function toRad(d) { return d * Math.PI / 180 }

function haversineKm(aLat, aLon, bLat, bLon) {
    const R = 6371
    const dLat = toRad(bLat - aLat)
    const dLon = toRad(bLon - aLon)
    const s1 = Math.sin(dLat / 2)
    const s2 = Math.sin(dLon / 2)
    const q = s1 * s1 + Math.cos(toRad(aLat)) * Math.cos(toRad(bLat)) * s2 * s2
    return 2 * R * Math.asin(Math.min(1, Math.sqrt(q)))
}

function hotspotWeight(item, freshness) {
    let w = 0
    if (item.state === "High") w += 10
    if (item.state === "Elevated") w += 6
    if (item.trend === "Rising") w += 5
    if (freshness.status === "Offline") w -= 3
    if (item.value == null || item.dateTime == null) w += 2
    return w
}

function buildHotspots(levelRows) {
    const candidates = levelRows
        .map(r => ({ ...r, lat: r.item.lat, lon: r.item.long }))
        .filter(r => {
            if (r.lat == null || r.lon == null) return false
            const st = r.item.state
            const rising = r.item.trend === "Rising"
            return st === "High" || st === "Elevated" || rising
        })

    if (candidates.length < HOTSPOT_MIN_POINTS) return []

    const visited = new Set()
    const clusters = []

    for (let i = 0; i < candidates.length; i++) {
        if (visited.has(i)) continue

        const queue = [i]
        const members = []
        visited.add(i)

        while (queue.length) {
            const idx = queue.pop()
            const a = candidates[idx]
            members.push(a)

            for (let j = 0; j < candidates.length; j++) {
                if (visited.has(j)) continue
                const b = candidates[j]
                const dist = haversineKm(a.lat, a.lon, b.lat, b.lon)
                if (dist <= HOTSPOT_RADIUS_KM) {
                    visited.add(j)
                    queue.push(j)
                }
            }
        }

        if (members.length >= HOTSPOT_MIN_POINTS) {
            let sumLat = 0, sumLon = 0, sumW = 0
            members.forEach(m => {
                const w = hotspotWeight(m.item, m.freshness)
                sumLat += m.lat
                sumLon += m.lon
                sumW += w
            })

            const centroid = { lat: sumLat / members.length, lon: sumLon / members.length }

            const worstMember = members
                .slice()
                .sort((a, b) => (hotspotWeight(b.item, b.freshness) - hotspotWeight(a.item, a.freshness)))[0]

            clusters.push({
                count: members.length,
                weight: sumW,
                centroid,
                worst: worstMember ? (worstMember.item.label || worstMember.item.id) : "Unknown"
            })
        }
    }

    clusters.sort((a, b) => {
        if (b.weight !== a.weight) return b.weight - a.weight
        return b.count - a.count
    })

    return clusters.slice(0, 5)
}

/* This was missing in your file and breaks the whole script */
function hotspotClass(count) {
    if (count >= 4) return "pillHotRed"
    if (count >= 2) return "pillHotAmber"
    return "pillHotGreen"
}

function updateHotspotPanel() {
    const el = document.getElementById("hotspotList")
    if (!el) return

    if (!latestHotspots.length) {
        el.innerHTML = "None"
        return
    }

    el.innerHTML = latestHotspots.map((h, idx) => {
        return `
            <div class="hotspotRow">
                <div>
                    <span class="pill">#${idx + 1}</span>
                    <span class="pill ${hotspotClass(h.count)}">${h.count} sites</span>
                    <span class="pill">Worst: ${escapeHtml(h.worst)}</span>
                </div>
                <div class="hotspotLink" data-hotspot="${idx}">Zoom</div>
            </div>
        `
    }).join("")

    el.querySelectorAll(".hotspotLink").forEach(a => {
        a.addEventListener("click", () => {
            const idx = Number(a.getAttribute("data-hotspot"))
            const h = latestHotspots[idx]
            if (!h) return
            map.setView([h.centroid.lat, h.centroid.lon], 12)
        })
    })
}

/* ------------------------------------------------------------
   Change detection since last refresh
   ------------------------------------------------------------ */
function makeSnapshot(levelRows) {
    const snap = {}
    levelRows.forEach(r => {
        const it = r.item
        const fr = r.freshness
        snap[it.id] = {
            id: it.id,
            label: it.label || it.id,
            state: it.state || "NoData",
            trend: it.trend || "NoData",
            reporting: fr.status || "Offline",
            value: it.value,
            dateTime: it.dateTime,
            unit: it.unitShort || it.unit || "",
            lat: it.lat,
            lon: it.long,
            district: it.district || null,
            riverName: it.riverName || null,
            catchmentName: it.catchmentName || null,
            rate: it.trendRatePerHour != null ? Number(it.trendRatePerHour) : null
        }
    })
    return snap
}

function summariseDelta(prevSnap, currSnap) {
    if (!prevSnap) return { text: "No previous snapshot yet", notable: [] }

    let escalatedToHigh = 0
    let escalatedToElevated = 0
    let newlyOffline = 0
    let newlyNoData = 0
    let newlyRising = 0

    const notable = []
    const ids = new Set([...Object.keys(prevSnap), ...Object.keys(currSnap)])

    ids.forEach(id => {
        const p = prevSnap[id]
        const c = currSnap[id]
        if (!c) return

        const pState = p ? p.state : "NoData"
        const cState = c.state

        const pRep = p ? p.reporting : "Offline"
        const cRep = c.reporting

        const pTrend = p ? p.trend : "NoData"
        const cTrend = c.trend

        const pHasData = p && p.value != null && p.dateTime
        const cHasData = c.value != null && c.dateTime

        if (pState !== "High" && cState === "High") {
            escalatedToHigh += 1
            notable.push(`${c.label} escalated to High`)
        }

        if ((pState !== "High" && pState !== "Elevated") && cState === "Elevated") {
            escalatedToElevated += 1
            notable.push(`${c.label} escalated to Elevated`)
        }

        if (pRep !== "Offline" && cRep === "Offline") {
            newlyOffline += 1
            notable.push(`${c.label} is now Offline`)
        }

        if (pHasData && !cHasData) {
            newlyNoData += 1
            notable.push(`${c.label} has lost data`)
        }

        if (pTrend !== "Rising" && cTrend === "Rising") {
            newlyRising += 1
            notable.push(`${c.label} is now Rising`)
        }
    })

    const parts = []
    if (escalatedToHigh) parts.push(`+${escalatedToHigh} to High`)
    if (escalatedToElevated) parts.push(`+${escalatedToElevated} to Elevated`)
    if (newlyRising) parts.push(`+${newlyRising} now Rising`)
    if (newlyOffline) parts.push(`+${newlyOffline} now Offline`)
    if (newlyNoData) parts.push(`+${newlyNoData} lost data`)

    const text = parts.length ? parts.join(" | ") : "No material changes since last refresh"
    return { text, notable: notable.slice(0, 8) }
}

function updateDeltaPanel(delta) {
    const el = document.getElementById("deltaSummary")
    if (!el) return

    if (!delta) {
        el.textContent = "No previous snapshot yet"
        return
    }

    let html = `<div>${escapeHtml(delta.text)}</div>`
    if (delta.notable && delta.notable.length) {
        html += `<div style="margin-top:6px">`
        delta.notable.forEach(n => { html += `<div>• ${escapeHtml(n)}</div>` })
        html += `</div>`
    }
    el.innerHTML = html
}

/* ------------------------------------------------------------
   Officer attention list + pulse
   ------------------------------------------------------------ */
function pillClassForState(state) {
    if (state === "High") return "pillRed"
    if (state === "Elevated") return "pillAmber"
    if (state === "Normal") return "pillGreen"
    return ""
}

function pillClassForTrend(trend) {
    if (trend === "Rising") return "pillRed"
    if (trend === "Falling") return "pillAmber"
    if (trend === "Steady") return "pillGreen"
    return ""
}

function pillClassForFreshness(status) {
    if (status === "Offline") return "pillRed"
    if (status === "Stale") return "pillAmber"
    if (status === "Delayed") return "pillAmber"
    if (status === "Live") return "pillGreen"
    return ""
}

function computeAttention(levelRows) {
    return levelRows
        .filter(r => r.item && r.item.value != null)
        .map(r => {
            const rate = r.item.trendRatePerHour != null ? Number(r.item.trendRatePerHour) : null
            const score =
                (r.item.state === "High" ? 300 : r.item.state === "Elevated" ? 200 : r.item.state === "Normal" ? 100 : 0) +
                (r.freshness.status === "Offline" ? 90 : r.freshness.status === "Stale" ? 60 : r.freshness.status === "Delayed" ? 30 : 0) +
                (r.item.trend === "Rising" ? 15 : r.item.trend === "Falling" ? 5 : 0) +
                (rate != null ? Math.min(50, Math.max(0, rate * 10)) : 0)
            return { r, score, rate }
        })
        .sort((a, b) => b.score - a.score)
        .slice(0, 8)
}

function updateAttentionPanel(attention) {
    const el = document.getElementById("attentionList")
    if (!el) return
    if (!attention.length) {
        el.innerHTML = "None"
        return
    }

el.innerHTML = attention.map(a => {
        const it = a.r.item
        const fr = a.r.freshness
        const rateTxt = a.rate != null ? `${a.rate.toFixed(3)} /hr` : "n/a"

        const stateClass = pillClassForState(it.state)
        const trendClass = pillClassForTrend(it.trend)
        const freshClass = pillClassForFreshness(fr.status)

        return `
            <div class="attentionRow">
                <div>
                    <span class="pill ${stateClass}">${escapeHtml(it.state || "NoData")}</span>
                    <span class="pill ${trendClass}">${escapeHtml(it.trend || "Unknown")}</span>
                    <span class="pill ${freshClass}">${escapeHtml(fr.status || "Unknown")}</span>
                    <span class="pill">${escapeHtml(rateTxt)}</span>
                    <div class="tiny">${escapeHtml(it.label || it.id)}</div>
                </div>
                <div class="hotspotLink" data-station="${escapeHtml(it.id)}">Zoom</div>
            </div>
        `
    }).join("")

    el.querySelectorAll(".hotspotLink").forEach(a => {
        const sid = a.getAttribute("data-station")
        a.addEventListener("click", () => zoomToStation(sid))
    })
}

function hotspotClass(count) {
    if (count >= 4) return "pillHotRed"
    if (count >= 2) return "pillHotAmber"
    return "pillHotGreen"
}

function districtSeverityScore(state) {
    if (state === "High") return 3
    if (state === "Elevated") return 2
    if (state === "Normal") return 1
    return 0
}

function updateTrafficLights(levelRows) {
    const el = document.getElementById("trafficLights")
    if (!el) return

    const byDistrict = {}
    levelRows.forEach(r => {
        const d = r.item.district || "Unknown"
        const sev = districtSeverityScore(r.item.state)
        byDistrict[d] = Math.max(byDistrict[d] || 0, sev)
    })

    const entries = Object.entries(byDistrict).sort((a, b) => a[0].localeCompare(b[0]))
    if (!entries.length) {
        el.innerHTML = `<div class="tiny">No district data</div>`
        return
    }

    el.innerHTML = entries.map(([name, sev]) => {
        const dotClass = sev === 3 ? "dot dotRed" : sev === 2 ? "dot dotAmber" : sev === 1 ? "dot dotGreen" : "dot dotGrey"
        return `
            <div class="trafficItem">
                <div>${escapeHtml(name)}</div>
                <span class="${dotClass}"></span>
            </div>
        `
    }).join("")
}

/* ------------------------------------------------------------
   Pulse markers
   ------------------------------------------------------------ */

function clearPulseMarkers() {
    Object.keys(pulseMarkers).forEach(id => {
        try { map.removeLayer(pulseMarkers[id]) } catch (e) {}
    })
    pulseMarkers = {}
}

function applyPulseToFastestRising(levelRows) {
    clearPulseMarkers()

    const rising = levelRows
        .filter(r => r.item.trend === "Rising" && r.item.lat != null && r.item.long != null)
        .map(r => {
            const rate = r.item.trendRatePerHour != null ? Number(r.item.trendRatePerHour) : null
            return { r, rate }
        })
        .filter(x => x.rate != null && Number.isFinite(x.rate))
        .sort((a, b) => b.rate - a.rate)
        .slice(0, 5)

    rising.forEach(x => {
        const it = x.r.item
        const colour = stateToColour(it.state)

        const icon = L.divIcon({
            className: "",
            html: `<div class="pulse" style="background:${colour}; --pulse-colour:${colour}"></div>`,
            iconSize: [12, 12],
            iconAnchor: [6, 6]
        })

        const m = L.marker([it.lat, it.long], {
            icon,
            interactive: false,
            keyboard: false,
            pane: "shadowPane"
        }).addTo(map)

        pulseMarkers[it.id] = m
    })
}

function zoomToStation(stationId) {
    if (!stationId) return
    const m = markers[stationId]
    if (!m) return
    try {
        map.setView(m.getLatLng(), 13)
        m.openPopup()
    } catch (e) {}
}

/* ------------------------------------------------------------
   Overlays
   ------------------------------------------------------------ */

let radarFrameUrl = null
let radarLoading = false

function removeAnyRadarLayers() {
    if (radarLayer && map.hasLayer(radarLayer)) {
        radarLayer.removeFrom(map)
    }

    map.eachLayer(l => {
        const url = (l && typeof l.getTileUrl === "function") ? l.getTileUrl({ x: 0, y: 0, z: 0 }) : ""
        if (typeof url === "string" && url.includes("rainviewer.com")) {
            try { map.removeLayer(l) } catch (e) {}
        }
    })
}

async function toggleRadar() {
    if (radarLayer) {
        if (map.hasLayer(radarLayer)) {
            removeAnyRadarLayers()
            radarOn = false
        } else {
            radarLayer.addTo(map)
            radarOn = true
        }
        return
    }

    if (radarLoading) return
    radarLoading = true

    try {
        const res = await fetch("https://api.rainviewer.com/public/weather-maps.json")
        if (!res.ok) return

        const j = await res.json()
        const frames = j?.radar?.past
        if (!frames || !frames.length) return

        const frame = frames[frames.length - 1]
        const host = j.host || "https://tilecache.rainviewer.com"
        const path = frame.path
        if (!path) return

        radarFrameUrl = `${host}${path}/256/{z}/{x}/{y}/2/1_1.png`

        radarLayer = L.tileLayer(radarFrameUrl, {
            opacity: 0.55,
            tileSize: 256,
            maxNativeZoom: 7,
            maxZoom: 18,
            updateWhenIdle: true,
            keepBuffer: 2
        })

        radarLayer.addTo(map)
        radarOn = true
    } catch (e) {
    } finally {
        radarLoading = false
    }
}

async function toggleWarnings() {
    warningsOn = !warningsOn
    if (!warningsOn) {
        if (warningsLayer) { map.removeLayer(warningsLayer); warningsLayer = null }
        return
    }

    try {
        const res = await fetch("/staffordshire/floodwarnings")
        if (!res.ok) return

        const raw = await res.json()

        const geo = {
            type: "FeatureCollection",
            features: (raw.features || []).filter(f => {
                const lvl = f?.properties?.severityLevel
                return lvl === 1 || lvl === 2
            })
        }

        if (warningsLayer) map.removeLayer(warningsLayer)

        warningsLayer = L.geoJSON(geo, {
            style: (f) => {
                const lvl = f?.properties?.severityLevel
                const colour = (lvl === 1) ? "#d7191c" : "#fdae61"
                return { color: colour, weight: 2, fillOpacity: 0.12 }
            },
            onEachFeature: (feature, layer) => {
                const p = feature.properties || {}
                const title = p.area || "Flood area"
                const sev = p.severity || ""
                const when = p.timeMessageChanged || p.timeRaised || ""
                const msg = p.message || ""
                layer.bindPopup(
                    `<b>${escapeHtml(title)}</b><br>` +
                    `${escapeHtml(sev)}<br>` +
                    `${escapeHtml(formatDateTime(when))}<br>` +
                    `<div style="margin-top:6px">${escapeHtml(msg)}</div>`
                )
            }
        }).addTo(map)
    } catch (e) {}
}

/* Make a non-interactive pane for polygons so they don't block station clicks */
if (!map.getPane("polygonsPane")) {
    map.createPane("polygonsPane")
    map.getPane("polygonsPane").style.zIndex = 250
    map.getPane("polygonsPane").style.pointerEvents = "none"
}

async function toggleCatchments() {
    catchmentsOn = !catchmentsOn
    if (!catchmentsOn) {
        if (catchmentsLayer) { map.removeLayer(catchmentsLayer); catchmentsLayer = null }
        return
    }

    try {
        const res = await fetch("/staffordshire/catchments")
        if (!res.ok) return
        const geo = await res.json()

        if (catchmentsLayer) map.removeLayer(catchmentsLayer)

        catchmentsLayer = L.geoJSON(geo, {
            pane: "polygonsPane",
            style: { color: "#111111", weight: 1, fillOpacity: 0.06 },
            onEachFeature: (f, layer) => {
                const p = f.properties || {}
                layer.bindPopup(`<b>${escapeHtml(p.catchmentName || "Catchment")}</b><br>Stations: ${escapeHtml(p.stationCount || 0)}`)
            }
        }).addTo(map)

        /* Extra safety: ensure SVG paths don't eat clicks */
        try {
            const el = catchmentsLayer.getPane && catchmentsLayer.getPane()
            if (el) el.style.pointerEvents = "none"
        } catch (e) {}
    } catch (e) {}
}

async function toggleDistricts() {
    districtsOn = !districtsOn
    if (!districtsOn) {
        if (districtsLayer) { map.removeLayer(districtsLayer); districtsLayer = null }
        return
    }

    try {
        const res = await fetch("/staffordshire/districts")
        if (!res.ok) return
        const geo = await res.json()

        if (districtsLayer) map.removeLayer(districtsLayer)

        districtsLayer = L.geoJSON(geo, {
            pane: "polygonsPane",
            style: { color: "#333333", weight: 1, fillOpacity: 0 },
            onEachFeature: (f, layer) => {
                const p = f.properties || {}
                layer.bindPopup(`<b>${escapeHtml(p.name || "District")}</b>`)
            }
        }).addTo(map)

        try {
            const el = districtsLayer.getPane && districtsLayer.getPane()
            if (el) el.style.pointerEvents = "none"
        } catch (e) {}
    } catch (e) {}
}

/* River labels: always rebuild from latestLevelRows, and rebuild after refresh if toggled on */
function rebuildRiverLabels() {
    if (riverLabelsLayer) { try { map.removeLayer(riverLabelsLayer) } catch (e) {} }
    riverLabelsLayer = null

    const groups = {}
    latestLevelRows.forEach(r => {
        const rn = r.item.riverName
        if (!rn || r.item.lat == null || r.item.long == null) return
        groups[rn] = groups[rn] || []
        groups[rn].push([r.item.lat, r.item.long])
    })

    const feats = []
    Object.entries(groups).forEach(([name, pts]) => {
        if (!pts.length) return
        const avgLat = pts.reduce((a, p) => a + p[0], 0) / pts.length
        const avgLon = pts.reduce((a, p) => a + p[1], 0) / pts.length
        feats.push({ name, lat: avgLat, lon: avgLon })
    })

    riverLabelsLayer = L.layerGroup()
    feats.forEach(f => {
        const icon = L.divIcon({
            className: "",
            html: `<div style="background:rgba(255,255,255,0.85);border:1px solid rgba(0,0,0,0.2);border-radius:999px;padding:2px 8px;font-size:11px">${escapeHtml(f.name)}</div>`,
            iconSize: null
        })
        L.marker([f.lat, f.lon], { icon, interactive: false, keyboard: false }).addTo(riverLabelsLayer)
    })

    riverLabelsLayer.addTo(map)
}

function toggleRiverLabels() {
    riverLabelsOn = !riverLabelsOn
    if (!riverLabelsOn) {
        if (riverLabelsLayer) { map.removeLayer(riverLabelsLayer); riverLabelsLayer = null }
        return
    }
    rebuildRiverLabels()
}
function exportSitrepPdf() {
    const rows = latestLevelRows.slice().sort((a, b) => {
        const sa = a.item.state === "High" ? 3 : a.item.state === "Elevated" ? 2 : a.item.state === "Normal" ? 1 : 0
        const sb = b.item.state === "High" ? 3 : b.item.state === "Elevated" ? 2 : b.item.state === "Normal" ? 1 : 0
        if (sb !== sa) return sb - sa
        return (a.item.label || "").localeCompare(b.item.label || "")
    })

    const win = window.open("", "_blank")
    if (!win) {
    alert("Popup blocked. Allow popups for this site to open the SITREP.")
    return
    }

    win.document.write(`
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Staffordshire Flood SITREP</title>
<style>
body{font-family:Arial,Helvetica,sans-serif;margin:24px}
h1{margin-bottom:4px}
.meta{color:#555;margin-bottom:16px}
table{border-collapse:collapse;width:100%;font-size:12px}
th,td{border:1px solid #ccc;padding:6px;text-align:left}
th{background:#f2f2f2}
.high{background:#ffd6d6}
.elevated{background:#fff0c7}
.normal{background:#e7f7e7}
</style>
</head>
<body>

<div style="display:flex;align-items:center;justify-content:space-between;gap:16px;margin-bottom:14px">
  <div>
    <h1 style="margin:0 0 4px 0">Staffordshire Flood SITREP</h1>
    <div class="meta">
      Generated: ${new Date().toLocaleString()}<br>
      Last refresh: ${lastRefreshLocal || "Unknown"}
    </div>
  </div>
  <img src="/static/CCU.png" alt="CCU" style="height:60px;object-fit:contain">
</div>

<h2>Hotspots</h2>
${latestHotspots && latestHotspots.length
    ? latestHotspots.map((h,i)=>`<div>${i+1}. ${h.worst} (${h.count} sites)</div>`).join("")
    : "<div>None</div>"}

<h2>Stations</h2>
<table>
<tr>
<th>Station</th>
<th>River</th>
<th>Level</th>
<th>Trend</th>
<th>Status</th>
<th>Reporting</th>
<th>Time</th>
</tr>

${rows.map(r=>{
    const it=r.item
    const fr=r.freshness
    const cls = (it.state||"").toLowerCase()
    const v=formatValueAndUnit(it).text
    return `<tr class="${cls}">
<td>${it.label||it.id||""}</td>
<td>${it.riverName||""}</td>
<td>${v}</td>
<td>${it.trend||""}</td>
<td>${it.state||""}</td>
<td>${fr.status||""}</td>
<td>${formatDateTime(it.dateTime)||""}</td>
</tr>`
}).join("")}

</table>

</body>
</html>
`)
    win.document.close()
}
/* ------------------------------------------------------------
   Modal + buttons
   ------------------------------------------------------------ */

const modalBack = document.getElementById("tableModalBack")

document.getElementById("btnTable")?.addEventListener("click", () => {
    if (!modalBack) return
    modalBack.style.display = "flex"
    renderTable()
})

document.getElementById("btnCloseTable")?.addEventListener("click", () => {
    if (!modalBack) return
    modalBack.style.display = "none"
})

modalBack?.addEventListener("click", (e) => {
    if (e.target === modalBack) modalBack.style.display = "none"
})

document.getElementById("tableSearch")?.addEventListener("input", () => {
    renderTable()
})

document.getElementById("btnCsv")?.addEventListener("click", exportCsvFromTable)
document.getElementById("btnPdf")?.addEventListener("click", () => {
    if (!latestLevelRows || latestLevelRows.length === 0) {
        alert("Data is still loading, wait a moment then try again.")
        return
    }
    exportSitrepPdf()
})

document.getElementById("btnWorst")?.addEventListener("click", () => {
    if (!worstStation) return
    zoomToStation(worstStation.id)
})

document.getElementById("btnRadar")?.addEventListener("click", toggleRadar)
document.getElementById("btnWarnings")?.addEventListener("click", toggleWarnings)
document.getElementById("btnCatchments")?.addEventListener("click", toggleCatchments)
document.getElementById("btnDistricts")?.addEventListener("click", toggleDistricts)
document.getElementById("btnRivers")?.addEventListener("click", toggleRiverLabels)

document.getElementById("markerMode")?.addEventListener("change", (e) => {
    markerMode = e.target.value || "all"
    applyMarkerMode()
})

/* ------------------------------------------------------------
   Data loading
   ------------------------------------------------------------ */

async function loadBoundary() {
    try {
        const res = await fetch("/staffordshire/boundary", { cache: "no-store" })
        if (!res.ok) throw new Error(`boundary ${res.status}`)
        const geojson = await res.json()

        if (boundaryLayer) map.removeLayer(boundaryLayer)

        boundaryLayer = L.geoJSON(geojson, {
            pane: "polygonsPane",
            style: { color: "#111111", weight: 2, fillOpacity: 0 }
        }).addTo(map)

        // Optional: zoom map to boundary once loaded
        try { map.fitBounds(boundaryLayer.getBounds(), { padding: [12, 12] }) } catch (e) {}
    } catch (e) {
        console.error("loadBoundary failed:", e)
    }
}

async function loadStations() {
    try {
        const res = await fetch("/staffordshire/stations", { cache: "no-store" })
        if (!res.ok) throw new Error(`stations ${res.status}`)
        const data = await res.json()

        Object.keys(markers).forEach(id => {
            try { map.removeLayer(markers[id]) } catch (e) {}
        })
        markers = {}

        ;(data.stations || []).forEach(st => {
            if (st.lat == null || st.long == null) return
            const marker = L.circleMarker([st.lat, st.long], markerBaseStyle())
            marker.addTo(map)
            marker.bindPopup("Loading...")
            markers[st.id] = marker
        })

        applyMarkerMode()
    } catch (e) {
        console.error("loadStations failed:", e)
    }
}

async function fetchStatusPage(offset, limit) {
    const url = `/staffordshire/status?offset=${offset}&limit=${limit}`
    const res = await fetch(url, { cache: "no-store", credentials: "same-origin" })

    if (res.status === 401) {
        console.error("401 Unauthorised for", url)
        throw new Error("401 Unauthorised")
    }

    if (!res.ok) throw new Error(`status ${res.status}`)
    return res.json()
}
/* ADD THIS FUNCTION */
async function refreshStatusAll() {
    let offset = 0
    let combined = []

    while (true) {
    const page = await fetchStatusPage(offset, PAGE_LIMIT)
    const items = page.items || []

    // APPLY MARKER UPDATES IMMEDIATELY
    items.forEach(item => {
        const m = markers[item.id]
        if (!m) return
        const freshness = classifyFreshness(item.dateTime)
        const colour = stateToColour(item.state)
        setMarkerStyle(m, colour)
        m.setPopupContent(buildPopup(item, freshness))
    })

    combined = combined.concat(items)
    if (items.length < PAGE_LIMIT) break
    offset += PAGE_LIMIT
    }

    latestItemsById = {}
    latestLevelRows = []

    const counts = { high: 0, elevated: 0, normal: 0, delayed: 0, stale: 0, offline: 0, nodata: 0 }
    let risingCount = 0
    let offlineCount = 0

    combined.forEach(item => {
        if (!item || !item.id) return
        latestItemsById[item.id] = item

        const freshness = classifyFreshness(item.dateTime)
        const m = markers[item.id]

        const isLevel = (item.parameter || "").toLowerCase() === "level" || (item.unitShort || "").toLowerCase() === "m"

        if (isLevel) {
            latestLevelRows.push({ item, freshness })
        }

        const colour = stateToColour(item.state)
        if (m) {
            setMarkerStyle(m, colour)
            m.setPopupContent(buildPopup(item, freshness))
        }

        const rep = freshness.status
        const st = item.state || "NoData"

        if (rep === "Delayed") counts.delayed += 1
        else if (rep === "Stale") counts.stale += 1
        else if (rep === "Offline") counts.offline += 1

        if (st === "High") counts.high += 1
        else if (st === "Elevated") counts.elevated += 1
        else if (st === "Normal") counts.normal += 1
        else counts.nodata += 1

        if (item.trend === "Rising") risingCount += 1
        if (rep === "Offline") offlineCount += 1
    })

    latestLevelRows.sort((a, b) => {
        const an = (a.item.label || a.item.id || "")
        const bn = (b.item.label || b.item.id || "")
        return an.localeCompare(bn)
    })

    latestHotspots = buildHotspots(latestLevelRows)
    updateHotspotPanel()

    const attention = computeAttention(latestLevelRows)
    updateAttentionPanel(attention)

    const snap = makeSnapshot(latestLevelRows)
    const delta = summariseDelta(previousSnapshotById, snap)
    updateDeltaPanel(delta)
    previousSnapshotById = snap

    requestAnimationFrame(() => {
    try { applyPulseToFastestRising(latestLevelRows) } catch (e) {}
    })

    worstStation = null
    let bestScore = -1
    latestLevelRows.forEach(r => {
        const s = worstScore(r.item, r.freshness)
        if (s > bestScore) {
            bestScore = s
            worstStation = r.item
        }
    })

    setIntel("intelWorst", worstStation ? (worstStation.label || worstStation.id) : "Unknown")
    setIntel("intelRising", risingCount)
    setIntel("intelOffline", offlineCount)

    lastRefreshLocal = new Date().toLocaleString()
    setIntel("intelLast", lastRefreshLocal)

    updateLegendCounts(counts)

    if (modalBack && modalBack.style.display === "flex") {
        renderTable()
    }
    applyMarkerMode()
}
/* ------------------------------------------------------------
   Init
   ------------------------------------------------------------ */

async function init() {
    await loadBoundary()
    await loadStations()
    await refreshStatusAll()

    setInterval(async () => {
        try { await refreshStatusAll() } catch (e) {}
    }, REFRESH_MS)
}

init()
</script>

</body>
</html>
